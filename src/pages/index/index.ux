<template>
  <div class="page" style="flex-direction: column;">
    <img if="{{allBooks.length == 0}}" static src="/common/images/empty.png" style="position: absolute;left: 50px;top: 186px;width: 92px;height: 92px;" />
    <text if="{{allBooks.length == 0}}" static style="position: absolute;left: 0px;top: 289px;width: 192px;line-height: 42px;font-weight:bold;font-size:22px;color:white;text-align:center;">书架空空</text>
    <list class="list" if="{{shelfStyle === 'list' && displayMode === 'all'}}">
      <list-item type="tip" if="{{showStorageWarning && isStorageLow}}" class="item" style="background-color: #ad0000;">
        <text style="color: white;font-size: 21px;">实际可用存储空间不足，将无法正常使用。</text>
      </list-item>
      <list-item for="{{visibleBooks}}" class="item" @click="selectFile($item)" type="nook">
        <marquee if="{{shelfMarqueeEnabled}}" scrollamount="22" class="itemtext" text-offset="25">{{$item.name}}</marquee>
        <text else class="itemtext">{{$item.name}}</text>
        <marquee if="{{shelfMarqueeEnabled}}" scrollamount="40" text-offset="25" class="itemtext2">{{getProgressSubtitle($item)}}</marquee>
        <text else class="itemtext2">{{getProgressSubtitle($item)}}</text>
      </list-item>
      <list-item type="pagination" class="pagination-container" if="{{totalPages > 1}}">
        <div class="pagination-controls">
          <img src="/common/images/pre.png" if="{{currentPage > 0}}" @click="prevPage" class="pagination-button" />
          <text class="pagination-text">{{currentPage + 1}} / {{totalPages}}</text>
          <img src="/common/images/next.png" if="{{currentPage < totalPages - 1}}" @click="nextPage" class="pagination-button" />
        </div>
      </list-item>
    </list>
    <list class="list" if="{{shelfStyle === 'cover' && displayMode === 'all'}}">
      <list-item type="tip" if="{{showStorageWarning && isStorageLow}}" class="item" style="background-color: #ad0000;">
        <text style="color: white;font-size: 21px;">实际可用存储空间不足，将无法正常使用。</text>
      </list-item>
      <list-item for="{{visibleBooks}}" class="item cover-item" @click="selectFile($item)" type="nook">
        <img if="{{$item.hasRealCover}}" class="cover-image" src="internal://files/books/{{$item.dirName}}/{{$item.coverFileName}}" />
        <div class="cover-image-placeholder" else></div>
        <div class="cover-content">
          <marquee if="{{shelfMarqueeEnabled}}" scrollamount="30" class="itemtext" text-offset="25">{{$item.name}}</marquee>
          <text else class="itemtext">{{$item.name}}</text>
          <marquee if="{{shelfMarqueeEnabled}}" scrollamount="40" class="itemtext2" text-offset="25">{{getProgressSubtitle($item)}}</marquee>
          <text else class="itemtext2">{{getProgressSubtitle($item)}}</text>
        </div>
      </list-item>
      <list-item type="pagination" class="pagination-container" if="{{totalPages > 1 && displayMode === 'all'}}">
        <div class="pagination-controls">
          <img src="/common/images/pre.png" if="{{currentPage > 0}}" @click="prevPage" class="pagination-button" />
          <text class="pagination-text">{{currentPage + 1}} / {{totalPages}}</text>
          <img src="/common/images/next.png" if="{{currentPage < totalPages - 1}}" @click="nextPage" class="pagination-button" />
        </div>
      </list-item>
    </list>
    <list class="list" if="{{displayMode === 'category'}}">
      <list-item type="tip" if="{{showStorageWarning && isStorageLow && !selectedCategory}}" class="item" style="background-color: #ad0000;">
        <text style="color: white;font-size: 21px;">实际可用存储空间不足，将无法正常使用。</text>
      </list-item>
      <list-item if="{{selectedCategory}}" class="item" @click="backToCategoryList" type="nook" style="height: 72px;">
        <text class="itemtext">← 返回分类</text>
      </list-item>
      <list-item for="{{visibleBooks}}" class="item {{shelfStyle === 'cover' ? 'cover-item' : ''}}" @click="handleCategoryItemClick($item)" type="nook">
        <img if="{{shelfStyle === 'cover' && $item.hasRealCover}}" class="cover-image" src="internal://files/books/{{$item.dirName}}/{{$item.coverFileName}}" />
        <div if="{{shelfStyle === 'cover' && !$item.hasRealCover}}" class="cover-image-placeholder"></div>
        <div class="{{shelfStyle === 'cover' ? 'cover-content' : 'category-item-content'}}">
          <marquee if="{{shelfMarqueeEnabled && !$item.isCategory}}" scrollamount="22" text-offset="25" class="itemtext">{{$item.name}}</marquee>
          <text else class="itemtext">{{$item.name}}</text>
          <marquee if="{{shelfMarqueeEnabled && !$item.isCategory}}" scrollamount="40" text-offset="25" class="itemtext2">{{getProgressSubtitle($item)}}</marquee>
          <text else class="itemtext2">{{getProgressSubtitle($item)}}</text>
        </div>
      </list-item>
      <list-item type="pagination" class="pagination-container" if="{{totalPages > 1}}">
        <div class="pagination-controls">
          <img src="/common/images/pre.png" if="{{currentPage > 0}}" @click="prevPage" class="pagination-button" />
          <text class="pagination-text">{{currentPage + 1}} / {{totalPages}}</text>
          <img src="/common/images/next.png" if="{{currentPage < totalPages - 1}}" @click="nextPage" class="pagination-button" />
        </div>
      </list-item>
    </list>
    <img static src="/common/images/hd.png" style="position: absolute;left: 0px;top: 0px;width: 192px;height: 102px;" />
    <img static src="/common/images/more.png" @click="routerTo('more')" style="position: absolute;left: 59px;top: 418px;width: 72px;height: 72px;" />
    <text style="position: absolute;top: 16px;width: 192px;line-height: 32px;font-weight:bold;font-size:18px;color:rgba(255,255,255,0.6);text-align:center;">
      {{nowTime}}
    </text>
    <text static style="position: absolute;top: 36px;width: 192px;line-height: 42px;font-weight:bold;font-size:26px;color:white;text-align:center;">
      电子书
    </text>
  </div>
</template>
<script>
import router from '@system.router';
import bookStorage from '../../utils/bookStorage.js'
import storage from '../../utils/storage.js';
import chapterManager from '../../utils/chapterManager.js';
import device from '@system.device';
import { calculateStorageInfo, isStorageLow } from '../../utils/storageUtils.js';
export default {
  private: {
    nowTime: "00:00",
    timer: null,
    shelfStyle: 'list',
    isNavigating: false,
    allBooks: [],
    visibleBooks: [],
    currentPage: 0,
    totalPages: 1,
    pageSize: 5,
    lastReadOnTop: true,
    shelfMarqueeEnabled: false,
    displayMode: 'all',
    categories: [],
    selectedCategory: null,
    categoryBooks: [],
    lastReadBook: null,
    homeProgressMode: 'book',
    showStorageWarning: false
  },
  updateTime() {
    const date = new Date();
    let hours = date.getHours();
    let minutes = date.getMinutes();
    hours = hours < 10 ? '0' + hours : hours;
    minutes = minutes < 10 ? '0' + minutes : minutes;
    this.nowTime = `${hours}:${minutes}`;
  },
  onInit() {
    this.updateTime();
    this.timer = setInterval(() => {
      this.updateTime();
    }, 1000);
    bookStorage.load();
  },
  onDestroy() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
    this.allBooks = null;
    this.visibleBooks = null;
    global.runGC();
  },
  onShow() {
    this.isNavigating = false;
    const shouldRestoreCategory = globalThis.fromCategoryPage && globalThis.selectedCategory;
    const categoryToRestore = shouldRestoreCategory ? globalThis.selectedCategory : null;
    const shouldRestoreHomePage = globalThis.fromHomePage && typeof globalThis.homePage === 'number';
    const homePageToRestore = shouldRestoreHomePage ? globalThis.homePage : null;
    if (shouldRestoreCategory) {
      globalThis.fromCategoryPage = false;
      globalThis.selectedCategory = null;
    }
    if (shouldRestoreHomePage) {
      globalThis.fromHomePage = false;
      globalThis.homePage = null;
    }
    if (!shouldRestoreHomePage) {
      this.currentPage = 0;
    }
    this.loadSettingsAndFiles().then(() => {
      if (shouldRestoreCategory && categoryToRestore) {
        this.displayMode = 'category';
        this.selectedCategory = categoryToRestore;
        this.updateCategoryView();
      } else if (shouldRestoreHomePage && homePageToRestore !== null && this.displayMode === 'all') {
        this.loadPage(homePageToRestore);
      }
      this.loadDeviceInfo();
    });
  },
  getStorage(key, defaultValue) {
    return new Promise((resolve) => {
      storage.get({
        key: key,
        success: (data) => {
          resolve(data || defaultValue);
        },
        fail: () => {
          resolve(defaultValue);
        }
      });
    });
  },
  async loadSettingsAndFiles() {
    const [pageSize, shelfStyle, lastReadOnTop, shelfMarqueeEnabled, displayMode, homeProgressMode, showStorageWarning, categoryPagination] = await Promise.all([
      this.getStorage('EBOOK_SHELF_PAGE_SIZE', '5'),
      this.getStorage('EBOOK_SHELF_STYLE', 'list'),
      this.getStorage('EBOOK_TOP_LAST_READ', 'true'),
      this.getStorage('EBOOK_SHELF_MARQUEE_ENABLED', 'false'),
      this.getStorage('EBOOK_HOME_DISPLAY_MODE', 'all'),
      this.getStorage('EBOOK_HOME_PROGRESS_MODE', 'book'),
      this.getStorage('EBOOK_SHOW_STORAGE_WARNING', 'true'),
      this.getStorage('EBOOK_CATEGORY_PAGINATION', 'false')
    ]);
    this.pageSize = parseInt(pageSize);
    this.shelfStyle = shelfStyle;
    this.lastReadOnTop = lastReadOnTop === 'true';
    this.shelfMarqueeEnabled = shelfMarqueeEnabled === 'true';
    this.displayMode = displayMode || 'all';
    this.homeProgressMode = homeProgressMode || 'book';
    this.showStorageWarning = showStorageWarning === 'true';
    this.categoryPagination = categoryPagination === 'true';
    await this.loadFileList();
  },
  async loadFileList() {
    this.allBooks = await bookStorage.getBooks();
    await this.syncChapterCounts();
    this.processBooks();
    if (this.displayMode === 'category') {
      this.updateCategories();
      this.updateCategoryView();
    } else {
      this.currentModeList = this.allBooks;
      this.loadPage(this.currentPage);
    }
    global.runGC();
  },
  async syncChapterCounts() {
    if (!Array.isArray(this.allBooks) || this.allBooks.length === 0) {
      return;
    }
    let hasUpdates = false;
    const tasks = this.allBooks.map(async (book) => {
      if (!book || !book.dirName) {
        return;
      }
      const storedCount = parseInt(book.chapterCount, 10) || 0;
      
      if (storedCount <= 0) {
        try {
            const actualCount = await chapterManager.getTotalChapters(book.dirName);
            if (actualCount > 0 && actualCount !== storedCount) {
            book.chapterCount = actualCount;
            hasUpdates = true;
            }
        } catch (e) { }
      }
    });
    await Promise.all(tasks);
    if (hasUpdates) {
      await bookStorage.updateBooks(this.allBooks);
    }
  },
  processBooks() {
    this.lastReadBook = null;
    if (this.lastReadOnTop && this.allBooks.length > 0) {
      let lastReadIndex = -1;
      let latestTimestamp = 0;
      this.allBooks.forEach((book, index) => {
        book.isLastRead = false;
        if (book.progress && book.progress.lastReadTimestamp > latestTimestamp) {
          latestTimestamp = book.progress.lastReadTimestamp;
          lastReadIndex = index;
        }
      });
      if (lastReadIndex > -1) {
        const lastReadBook = this.allBooks.splice(lastReadIndex, 1)[0];
        lastReadBook.isLastRead = true;
        this.allBooks.unshift(lastReadBook);
        this.lastReadBook = lastReadBook;
      }
    }
    this.allBooks.forEach(book => {
      book.hasRealCover = !!(book.hasCover && book.coverFileName);
    });
  },
  updateCategories() {
    const categorySet = new Set();
    let hasUncategorized = false;
    this.allBooks.forEach(book => {
      if (book.localCategory) {
        categorySet.add(book.localCategory);
      } else {
        hasUncategorized = true;
      }
    });
    this.categories = Array.from(categorySet).sort();
    if (hasUncategorized) {
      this.categories.push('未分类');
    }
  },
  updateCategoryView() {
    if (this.selectedCategory) {
      if (this.selectedCategory === '未分类') {
        this.categoryBooks = this.allBooks.filter(book => !book.localCategory);
      } else {
        this.categoryBooks = this.allBooks.filter(book => book.localCategory === this.selectedCategory);
      }
      this.currentModeList = this.categoryBooks;
    } else {
      const categoryItems = this.categories.map(cat => ({
        isCategory: true,
        categoryName: cat,
        name: cat,
        bookCount: cat === '未分类'
          ? this.allBooks.filter(b => !b.localCategory).length
          : this.allBooks.filter(b => b.localCategory === cat).length
      }));
      if (this.lastReadBook) {
        this.currentModeList = [this.lastReadBook, ...categoryItems];
      } else {
        this.currentModeList = categoryItems;
      }
    }

    if (this.categoryPagination) {
        this.loadPage(this.currentPage);
    } else {
        this.visibleBooks = this.currentModeList;
        this.totalPages = 1;
        this.currentPage = 0;
    }
  },
  selectCategory(categoryName) {
    if (typeof categoryName === 'object' && categoryName.categoryName) {
      categoryName = categoryName.categoryName;
    }
    this.selectedCategory = categoryName;
    this.currentPage = 0;
    this.updateCategoryView();
  },
  backToCategoryList() {
    this.selectedCategory = null;
    this.currentPage = 0;
    this.updateCategoryView();
  },
  handleCategoryItemClick(item) {
    if (item.isCategory) {
      this.selectCategory(item.categoryName);
    } else {
      this.selectFile(item);
    }
  },
  roundToDecimal(num, decimalPlaces) {
    const parsed = parseFloat(num);
    if (isNaN(parsed)) {
      return (0).toFixed(decimalPlaces);
    }
    return parsed.toFixed(decimalPlaces);
  },
  getChapterProgressPercent(book) {
    if (!book || !book.progress) {
      return 0;
    }
    let percent = book.progress.chapterProgressPercent;
    if (typeof percent === 'string') {
      percent = parseFloat(percent);
    }
    if (typeof percent !== 'number' || isNaN(percent)) {
      percent = 0;
    }
    return Math.min(100, Math.max(0, percent));
  },
  getBookProgressPercent(book) {
    if (!book || !book.progress) {
      return 0;
    }
    const totalChapters = parseInt(book.chapterCount, 10) || 0;
    if (totalChapters <= 0) {
      return 0;
    }
    const chapterIndex = typeof book.progress.chapterIndex === 'number' && book.progress.chapterIndex >= 0
      ? book.progress.chapterIndex
      : 0;
    const chapterFraction = this.getChapterProgressPercent(book) / 100;
    const progressValue = ((chapterIndex + chapterFraction) / totalChapters) * 100;
    return Math.min(100, Math.max(0, progressValue));
  },
  getProgressSubtitle(book) {
    if (!book) {
      return '暂无进度';
    }
    if (book.isCategory) {
      return `共 ${book.bookCount || 0} 本`;
    }
    const prefix = book.isLastRead ? '上次阅读 · ' : '';
    const progress = book.progress || {};
    if (progress.chapterIndex === null || progress.chapterIndex === undefined || progress.chapterIndex < 0) {
      return `${prefix}尚未开始`;
    }
    if (this.homeProgressMode === 'chapter') {
      const chapterPercent = this.roundToDecimal(this.getChapterProgressPercent(book), 2) || 0;
      return `${prefix}${chapterPercent}% · 本章进度`;
    }
    const bookPercent = this.roundToDecimal(this.getBookProgressPercent(book), 2) || 0;
    const totalChapters = parseInt(book.chapterCount, 10) || 0;
    if (totalChapters <= 0) {
      return `${prefix}${bookPercent}% · 章节信息缺失`;
    }
    const currentChapter = Math.min(totalChapters, (progress.chapterIndex || 0) + 1);
    return `${prefix}${bookPercent}% · 看到 ${currentChapter} / ${totalChapters} 章`;
  },
  loadPage(page) {
    const list = this.currentModeList || this.allBooks;
    this.totalPages = Math.ceil(list.length / this.pageSize) || 1;
    let safePage = Math.max(0, Math.min(page, this.totalPages - 1));
    if (this.totalPages > 0) {
      const start = safePage * this.pageSize;
      const end = start + this.pageSize;
      this.visibleBooks = list.slice(start, end);
      this.currentPage = safePage;
    } else {
      this.visibleBooks = [];
      this.currentPage = 0;
    }
  },
  prevPage() {
    if (this.currentPage > 0) {
      this.loadPage(this.currentPage - 1);
    }
  },
  nextPage() {
    if (this.currentPage < this.totalPages - 1) {
      this.loadPage(this.currentPage + 1);
    }
  },
  async selectFile(item) {
    if (this.isNavigating || item.isCategory) {
      return;
    }
    this.isNavigating = true;
    globalThis.enteringDetailView = true;
    if (this.displayMode === 'category' && this.selectedCategory) {
      globalThis.fromCategoryPage = true;
      globalThis.selectedCategory = this.selectedCategory;
      globalThis.fromHomePage = false;
      globalThis.homePage = null;
    } else if (this.displayMode === 'all') {
      globalThis.fromCategoryPage = false;
      globalThis.selectedCategory = null;
      globalThis.fromHomePage = true;
      globalThis.homePage = this.currentPage;
    } else {
      globalThis.fromCategoryPage = false;
      globalThis.selectedCategory = null;
      globalThis.fromHomePage = false;
      globalThis.homePage = null;
    }
    router.push({
      uri: '/pages/detail',
      params: {
        name: item.dirName
      }
    });
  },
  routerTo(page) {
    router.push({
      uri: `/pages/${page}`
    });
  },
  loadDeviceInfo() {
    if (!this.showStorageWarning) {
        this.isStorageLow = false;
        return;
    }
    device.getInfo({
      success: (ret) => {
        device.getTotalStorage({
          success: (data) => {
            const totalStorage = data.totalStorage || 0;
            device.getAvailableStorage({
              success: (availData) => {
                const availableStorage = availData.availableStorage || 0;
                const storageInfo = calculateStorageInfo(totalStorage, availableStorage, ret.product);
                this.isStorageLow = isStorageLow(storageInfo.actualAvailable);
              }
            });
          }
        });
      }
    });
  }
};
</script>
<style>
.page {
  width: 192px;
  height: 490px;
  background-color: #000000;
}

.list {
  width: 192px;
  height: 490px;
  position: absolute;
  top: 0px;
  left: 0px;
  padding: 86px 12px;
}

.item {
  width: 100%;
  height: 85px;
  padding: 12px 18px;
  margin-bottom: 8px;
  background-color: #262626;
  border-radius: 26px;
  flex-direction: column;
  justify-content: space-around;
  align-items: flex-start;
}

.cover-item {
  flex-direction: row;
  align-items: center;
  justify-content: flex-start;
  padding: 8px 12px;
  height: 105px;
}

.cover-image {
  width: 52px;
  height: 70px;
  background-color: #333;
  margin-right: 12px;
  border-radius: 8px;
  object-fit: cover;
  flex-shrink: 0;
}

.cover-image-placeholder {
  width: 52px;
  height: 70px;
  background-color: #1a1a1a;
  margin-right: 12px;
  border-radius: 8px;
  flex-shrink: 0;
}

.cover-content {
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  flex: 1;
  height: 100%;
  overflow: hidden;
}

.category-item-content {
  flex-direction: column;
  justify-content: space-around;
  align-items: flex-start;
  flex: 1;
  height: 100%;
  overflow: hidden;
}

.itemtext {
  font-size: 23px;
  width: 100%;
  font-weight: bold;
  color: white;
  text-overflow: ellipsis;
  lines: 1;
}

.itemtext2 {
  font-size: 16px;
  font-weight: bold;
  color: rgba(255, 255, 255, 0.6);
  text-overflow: ellipsis;
  lines: 1;
}

.pagination-container {
  width: 100%;
  height: 80px;
  justify-content: center;
  align-items: center;
}

.pagination-controls {
  width: 100%;
  flex-direction: row;
  align-items: center;
  justify-content: space-around;
  padding: 0 8px;
}

.pagination-button {
  width: 62px;
  height: 62px;
}

.pagination-text {
  font-size: 21px;
  font-weight: bold;
  color: white;
}
</style>
