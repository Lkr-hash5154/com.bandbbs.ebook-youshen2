<template>
	<div class="page">
	  <scroll id="scrollId"
		style="position: absolute; width: 336px; height: {{scrollHeight}}px; top: {{verticalMargin}}px;"
		scroll-y="{{true}}"
		scroll-top="{{scrollTopValue}}"
		@scroll="onScroll"
		@scrolltop="onScrollTop"
		@scrollbottom="onScrollBottom"
		@click="onTxtClick"
		onlongpress="onTxtLongPress"
		>
		<div id="contentContainer" style="position: absolute; width:336px; flex-direction: column;">
		  <div id="page1" style="flex-direction: column; width: 100%; flex-shrink: 0">
			<div for="{{(index, value) in page1.lines}}" class="item">
			  <text style="width: 336px; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">
				{{ value }}
			  </text>
			</div>
		  </div>
		  <div id="page2" style="flex-direction: column; width: 100%; flex-shrink: 0">
			<div for="{{(index, value) in page2.lines}}" class="item">
			  <text style="width: 336px; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">
				{{ value }}
			  </text>
			</div>
		  </div>
		</div>
	  </scroll>
		<img show="{{showSetting}}" src="/common/images/hd.png" style="position: absolute;left: 0px;top: 0px;width: 336px;height: 102px;" />
		<img show="{{showSetting}}" src="/common/images/back.png" @click="back" style="position: absolute;left: 6px;top: 6px;width: 72px;height: 72px;"/>
		<img show="{{showSetting}}" src="/common/images/more.png" @click="gotoSetting" style="position: absolute;left: 258px;top: 6px;width: 72px;height: 72px;"/>
		<text show="{{showSetting}}" style="position: absolute;left: 78px;top: 7px;width: 180px;line-height: 32px;font-weight:bold;font-size:24px;color:rgba(255,255,255,0.6);text-align:center;">
			{{nowTime}}
		</text>
		<marquee scrollamount="12" show="{{showSetting}}" style="position: absolute;left: 78px;top: 35px;width: 180px;line-height: 42px;font-weight:bold;font-size:32px;color:white;text-align:center;">
			{{currentChapterName}}
		</marquee>

		<img show="{{showSetting}}" src="/common/images/bt.png" style="position: absolute;left: 0px;top: 378px;width: 336px;height: 102px;" />
        <img show="{{showSetting}}" src="{{ isKeepScreenOn ? '/common/images/brightness.png' : '/common/images/brightness_off.png' }}" @click="toggleKeepScreenOn" style="position: absolute;left: 6px;top: 402px;width: 72px;height: 72px;"/>
		<div show="{{showSetting}}" style="position: absolute; top: 402px; left: 78px; width: 180px; height: 72px; flex-direction: column; justify-content: flex-start; align-items: center;">
			<text style="line-height: 42px;font-weight:bold;font-size:32px;color:white;text-align:center;">
				{{currentPage}} / {{totalPages}}
			</text>
			<text style="line-height: 32px;font-weight:bold;font-size:24px;color:rgba(255,255,255,0.6);text-align:center;">
				阅读进度
			</text>
		</div>
        <img show="{{showSetting}}" src="/common/images/add_bookmark.png" @click="addBookmark" @longpress="gotoBookmarks" style="position: absolute;left: 258px;top: 402px;width: 72px;height: 72px;"/>
		<img if="{{isAtChapterEnd && !showSetting}}" src="/common/images/next.png" @click="goToNextChapter" style="position: absolute; right: 20px; bottom: 20px; width: 72px; height: 72px;"/>
		<img if="{{isAtChapterStart && !showSetting}}" src="/common/images/pre.png" @click="goToPrevChapter" style="position: absolute; left: 20px; bottom: 20px; width: 72px; height: 72px;"/>
		
		<!-- 章节进度条 -->
		<div if="{{showProgressBar && !showSetting}}" class="progress-bar-container">
			<div class="progress-bar-bg">
				<div class="progress-bar-fill" style="width: {{chapterProgress}}%;"></div>
			</div>
		</div>
	</div>
  </template>

  <script>
	import prompt from '@system.prompt'
	import file from '@system.file'
	import router from '@system.router'
    import storage from '../../common/storage.js'
	import bookStorage from '../../common/bookStorage.js'
	import chapterManager from '../../common/chapterManager.js'
	import brightness from '@system.brightness'
	import app from '@system.app'

	var allSize = 0;
    let autoInterval = null;

	export default {
	  private: {
		txtSizePage: 400,
		fontSize: 30,
		lineHeight: 34,
		pageHeigh: 480,
		verticalMargin: 0,
		scrollHeight: 480,
		showSetting: true,
		loadingNext: false,
		loadingPrev: false,
		page1: { lines: ["加载中..."], offset: 0, length: 0 },
		page2: null,
		currentFileOffset: 0,
		opacity: 100,
		swipe: 'column',
		auto: false,
		nowTime: "00:00",
		timer: null,
		savedScrollOffset: 0,
      	currentScrollTop: 0,
		totalPages: 0,
		currentPage: 0,
		isKeepScreenOn: false,
		currentChapterIndexInAll: 0,
		currentChapterName: "",
		cPath: "",
		isAtChapterEnd: false,
		isAtChapterStart: false,
		scrollTopValue: 0,
		wait: false,
		longPressTriggered: false,
		saveDataTimeout: null,
		allChapters: [],
		teacherScreenEnabled: false,
		clickCount: 0,
		clickTimeout: null,
		chapterProgress: 0,
		showProgressBar: true
	  },
	  protected: {
		name: '',
		chapterIndex: -1,
		chapterName: ''
	  },
	  updateTime() {
		const date = new Date();
		let hours = date.getHours();
		let minutes = date.getMinutes();
		hours = hours < 10 ? '0' + hours : hours;
		minutes = minutes < 10 ? '0' + minutes : minutes;
		this.nowTime = `${hours}:${minutes}`;
	 },
	updatePageNumber(){
		this.currentPage = this.currentChapterIndexInAll + 1;
		this.totalPages = this.allChapters.length;
	},
	onInit(){
		this.updateTime();
		this.timer = setInterval(() => { this.updateTime(); }, 1000);
		this.loadBook();
		this.loadSettings();
	},
	async onShow(){
		this.loadSettings();
		storage.get({
			key: 'EBOOK_TEACHER_SCREEN_ENABLED',
			success: (data) => {
				this.teacherScreenEnabled = data === 'true';
			}
		});
		if (globalThis.justJumpedFromChapter || globalThis.justJumpedFromBookmark || globalThis.justJumpedFromPageNumber) {
            if(globalThis.justJumpedFromChapter) {
			    this.chapterIndex = globalThis.newChapterIndex;
			    this.chapterName = globalThis.newChapterName;
                delete globalThis.newChapterIndex;
			    delete globalThis.newChapterName;
            }
			await this.loadBook();
		}
	},
	loadSettings() {
		storage.get({ key: 'EBOOK_TXTSZPAGE', success: (data) => { if (data) this.txtSizePage = parseInt(data); } });
		storage.get({ key: 'EBOOK_VERTICAL_MARGIN', success: (data) => { 
			if (data) {
				this.verticalMargin = parseInt(data);
				this.updateScrollHeight();
			}
		}});
		storage.get({ key: 'EBOOK_FONT',
		  success: (data) => {
			if(data){ this.fontSize = parseInt(data); }
			this.lineHeight = parseInt((-0.01)*(this.fontSize**2) + 1.62*this.fontSize - 3.23);
			this.updateScrollHeight();
		  }
		});
		storage.get({ key: 'EBOOK_OPACITY', success: (data) => { if (data) this.opacity = parseInt(data) } });
		storage.get({ key: 'EBOOK_SWIPE', success: (data) => { if (data) this.swipe = data } });
		storage.get({ key: 'EBOOK_AUTO', success: (data) => { if(!data)return; const { speed, enable } = JSON.parse(data); if(enable)this.auto = speed; } });
		storage.get({ key: 'EBOOK_SHOW_PROGRESS_BAR', success: (data) => { if (data !== '') this.showProgressBar = data === 'true'; } });
	},
	updateScrollHeight() {
		this.scrollHeight = 480 - this.verticalMargin * 2;
		this.pageHeigh = Math.floor(this.scrollHeight/this.lineHeight) * this.lineHeight;
	},
	async loadBook() {
		try {
			
			this.allChapters = await chapterManager.loadChapterList(this.name);
		} catch (e) {
			prompt.showToast({ message: '章节列表加载失败' });
			this.allChapters = [];
			return;
		}

		if (!this.allChapters || this.allChapters.length === 0) {
			this.page1 = { lines: ["本书没有内容"], offset: 0, length: 0 };
			return;
		}

		const progress = await bookStorage.get(this.name);
		let chapterToLoadIndex;
		let offsetInChapter = 0;
		let scrollOffset = 0;

		if (globalThis.justJumpedFromChapter) {
			chapterToLoadIndex = this.chapterIndex;
			this.currentChapterName = this.chapterName;
			offsetInChapter = 0;
			scrollOffset = 0;
			globalThis.justJumpedFromChapter = false;
		} else if (globalThis.justJumpedFromBookmark || globalThis.justJumpedFromPageNumber) {
			chapterToLoadIndex = progress.chapterIndex;
			offsetInChapter = progress.offsetInChapter || 0;
			scrollOffset = progress.scrollOffset || 0;
			globalThis.justJumpedFromBookmark = false;
			globalThis.justJumpedFromPageNumber = false;
		} else if (progress.chapterIndex !== null) {
			chapterToLoadIndex = progress.chapterIndex;
			offsetInChapter = progress.offsetInChapter || 0;
			scrollOffset = progress.scrollOffset || 0;
		} else {
			chapterToLoadIndex = this.allChapters[0].index;
		}

		let chapterArrayIndex = this.allChapters.findIndex(c => c.index === chapterToLoadIndex);
		if (chapterArrayIndex === -1) {
			chapterToLoadIndex = this.allChapters[0].index;
			chapterArrayIndex = 0;
		}

		this.currentFileOffset = offsetInChapter;
		this.savedScrollOffset = scrollOffset;
		this.scrollTopValue = scrollOffset;
		this.currentScrollTop = scrollOffset;

		this.loadChapter(chapterArrayIndex, () => {
			this.loadInitialSegments();
			this.isAtChapterStart = this.currentFileOffset === 0 && this.savedScrollOffset < 10;
		});
	},
	loadChapter(chapterIdxInAll, callback) {
		if (!this.allChapters || chapterIdxInAll < 0 || chapterIdxInAll >= this.allChapters.length) {
			if(callback) callback();
			return;
		}
		
		
		if (this.page1) {
			this.page1.lines = null;
			this.page1 = null;
		}
		if (this.page2) {
			this.page2.lines = null;
			this.page2 = null;
		}
		
		
		this.page1 = { lines: [], offset: 0, length: 0 };
		this.page2 = null;
		
		this.isAtChapterStart = false;
		this.isAtChapterEnd = false;
		const chapter = this.allChapters[chapterIdxInAll];
		this.currentChapterIndexInAll = chapterIdxInAll;
		this.currentChapterName = chapter.name;
		this.cPath = `internal://files/books/${this.name}/content/${chapter.index}.txt`;

		file.get({
			uri: this.cPath,
			success: (data) => {
				allSize = data.length;
				this.updatePageNumber();
				if(callback) callback();
			},
			fail: (data, code) => {
				allSize = 0;
                prompt.showToast({ message: `加载章节失败: ${code}` });
				if(callback) callback();
			}
		});
	},
	loadInitialSegments(){
		var that = this;
		this.wait = true;
		this.readFileText(this.currentFileOffset, function(str, bytesRead){
		  that.page1 = { lines: str.split('\n'), offset: that.currentFileOffset, length: bytesRead };
		  that.loadNextSegmentNoScroll();
		  that.updateChapterProgress();
		});
	},
	loadNextSegmentNoScroll(){
		var that = this;
		let newOffset = that.page1.offset + that.page1.length;
		if(newOffset >= allSize) {
			that.isAtChapterEnd = true;
			that.page2 = null;
			that.restoreScrollPosition();
			return;
		}
	
		that.readFileText(newOffset, function(str, bytesRead){
			if(str){
				that.page2 = { lines: str.split('\n'), offset: newOffset, length: bytesRead };
			} else {
				that.page2 = null;
			}
			that.restoreScrollPosition();
		});
	},
	restoreScrollPosition() {
		setTimeout(() => {
			this.scrollTopValue = this.savedScrollOffset;
			this.currentScrollTop = this.savedScrollOffset;
			this.wait = false;
			this.updateChapterProgress();
			this.saveData(true);
		}, 50);
	},
	readFileText(readOffset, cb){
		if(readOffset >= allSize){ cb('', 0); return; }
		var length = this.txtSizePage * 2;
		if(readOffset < 0){ length += readOffset; readOffset = 0; }
		if((readOffset + length) >= allSize){ length = allSize - readOffset; }
		
		file.readArrayBuffer({
		  uri: this.cPath, position: readOffset, length: length,
		  success: function(data){
			var str = '';
			for(var i = 0; i < data.buffer.length; i += 2){
			  str += String.fromCharCode(data.buffer[i+1]*256 + data.buffer[i]);
			}
			cb(str, length);
		  },
		  fail: function(){ cb('', 0); }
		});
	},
	onScroll(e){
		if (this.isAtChapterEnd && e.scrollY < this.currentScrollTop) {
			this.isAtChapterEnd = false;
		}
		this.currentScrollTop = e.scrollY;
		this.isAtChapterStart = this.currentFileOffset === 0 && this.currentScrollTop < 10;
		this.saveData();
	},
	onScrollTop(){
		if (this.wait) return;
		if (this.currentFileOffset > 0) {
			if(!this.loadingPrev){ this.loadingPrev = true; this.loadPrevSegment(); }
		}
	},
	onScrollBottom(){
		if (this.wait) return;
		if(!this.loadingNext){ this.loadingNext = true; this.loadNextSegment(); }
	},
	loadNextSegment(){
		this.wait = true;
		var that = this;
		let lastSeg = that.page2 || that.page1;
		let newOffset = lastSeg.offset + lastSeg.length;

		if(newOffset >= allSize) {
			that.loadingNext = false;
			that.isAtChapterEnd = true;
			that.wait = false;
			return;
		}

		this.readFileText(newOffset, function (str, bytesRead) {
			that.loadingNext = false;
			if(str){
				const nextPageData = { lines: str.split('\n'), offset: newOffset, length: bytesRead };
				that.shiftPagesForward(nextPageData);
			} else {
				that.wait = false;
			}
		});
	},
	shiftPagesForward(nextPageData) {
		var that = this;
		const scrollPosBeforeLoad = this.currentScrollTop;
		that.$element("page1").getBoundingClientRect({
			success: function(rect){
				let removedHeight = rect.height;
				
				
				if (that.page1 && that.page1 !== that.page2) {
					that.page1.lines = null;
				}
				
				that.page1 = that.page2 || that.page1;
				that.page2 = nextPageData;
				
				const newScrollPos = scrollPosBeforeLoad - removedHeight + that.lineHeight;
				that.scrollTopValue = newScrollPos;
				that.currentScrollTop = newScrollPos;

				that.currentFileOffset = that.page1.offset;
				that.updateChapterProgress();
				that.saveData(true);
				that.wait = false;
			},
			fail: function() {
				that.wait = false;
			}
		});
	},
	loadPrevSegment(){
		this.wait = true;
		var that = this;
		if(that.page1.offset <= 0){
			this.wait = false;
			this.loadingPrev = false;
			return;
		}

		let newOffset = that.page1.offset - this.txtSizePage * 2;
		if(newOffset < 0) newOffset = 0;

		this.readFileText(newOffset, function (str, bytesRead) {
			that.loadingPrev = false;
			if(str){
				const prevPageData = { lines: str.split('\n'), offset: newOffset, length: bytesRead };
				
				
				if (that.page2) {
					that.page2.lines = null;
				}
				
				that.page2 = that.page1;
				that.page1 = prevPageData;
				that.$element("page1").getBoundingClientRect({
					success: function(rect){
						const newScrollPos = that.currentScrollTop + rect.height;
						that.scrollTopValue = newScrollPos;
						that.currentScrollTop = newScrollPos;
						that.currentFileOffset = that.page1.offset;
						that.updateChapterProgress();
						that.saveData(true);
						that.wait = false;
					},
					fail: function() {
						that.wait = false;
					}
				});
			} else {
				that.wait = false;
			}
		});
	},
	goToPrevChapter() {
		if (this.wait) return;
		this.wait = true;

		const prevChapterIndex = this.currentChapterIndexInAll - 1;
		if (prevChapterIndex < 0) {
			prompt.showToast({ message: '已是第一章' });
			this.wait = false;
			return;
		}
		
		this.isAtChapterEnd = false;

		this.loadChapter(prevChapterIndex, () => {
			this.loadLastSegmentsAndScrollToEnd();
		});
	},
	loadLastSegmentsAndScrollToEnd() {
        const that = this;
        this.wait = true;

        let offset2 = Math.max(0, allSize - (this.txtSizePage * 2));
        let offset1 = Math.max(0, offset2 - (this.txtSizePage * 2));
        
        if (offset1 === offset2 && allSize > 0) {
            offset1 = 0;
            offset2 = -1;
        } else if (offset1 === offset2) {
            this.page1 = { lines: [""], offset: 0, length: 0 };
            this.page2 = null;
            this.isAtChapterEnd = true;
            this.isAtChapterStart = true;
            this.wait = false;
            return;
        }

        this.currentFileOffset = offset1;

        this.readFileText(offset1, function(str1, bytesRead1) {
            that.page1 = { lines: str1.split('\n'), offset: offset1, length: bytesRead1 };

            if (offset2 === -1 || offset2 >= allSize) {
                that.page2 = null;
                that.isAtChapterEnd = true;
                that.scrollToEnd();
                return;
            }

            that.readFileText(offset2, function(str2, bytesRead2) {
                if (str2) {
                    that.page2 = { lines: str2.split('\n'), offset: offset2, length: bytesRead2 };
                } else {
                    that.page2 = null;
                }
                that.isAtChapterEnd = true;
                that.scrollToEnd();
            });
        });
    },
    scrollToEnd() {
        setTimeout(() => {
            this.$element("contentContainer").getBoundingClientRect({
                success: (rect) => {
                    const contentHeight = rect.height;
                    const scrollPos = contentHeight - this.scrollHeight;
                    const finalScrollTop = scrollPos > 0 ? scrollPos : 0;

                    this.scrollTopValue = finalScrollTop - 1;

                    setTimeout(() => {
                        this.scrollTopValue = finalScrollTop;
                        this.currentScrollTop = finalScrollTop;
                        this.wait = false;
                        this.isAtChapterStart = this.scrollTopValue < 10 && this.currentFileOffset === 0;
                        this.updateChapterProgress();
                        this.saveData(true);
                    }, 50);
                },
                fail: () => {
                    this.wait = false;
                }
            });
        }, 150);
    },
	goToNextChapter() {
		if (this.wait) return;
		this.wait = true;
	
		const nextChapterIndex = this.currentChapterIndexInAll + 1;
		if (nextChapterIndex >= this.allChapters.length) {
			prompt.showToast({ message: '已是最后一章' });
			if (autoInterval) {
				clearInterval(autoInterval);
				autoInterval = null;
				prompt.showToast({ message: '已关闭自动翻页' });
				if (!this.isKeepScreenOn) {
					brightness.setKeepScreenOn({ keepScreenOn: false });
				}
			}
			this.wait = false;
			return;
		}
		
		this.isAtChapterEnd = false;
		this.currentFileOffset = 0;
		this.savedScrollOffset = 0;
		this.scrollTopValue = 0;
		this.currentScrollTop = 0;
		
		this.loadChapter(nextChapterIndex, () => {
			this.page1 = { lines: ["加载中..."], offset: 0, length: 0 };
			this.page2 = null;
			this.loadInitialSegments();
			this.isAtChapterStart = true;
			this.chapterProgress = 0;
			this.saveData(true);
		});
	},
	saveData(forceImmediate = false){
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (forceImmediate) {
			this._performSave();
		} else {
			this.saveDataTimeout = setTimeout(() => {
				this._performSave();
			}, 2000);
		}
	},
	async _performSave() {
		if (!this.name || this.allChapters.length === 0) return;
		
		try {
			
			const savePromise = this._performSaveInternal();
			const timeoutPromise = new Promise((resolve) => setTimeout(resolve, 500));
			await Promise.race([savePromise, timeoutPromise]);
		} catch (e) {
			console.error('Save failed:', e);
		}
	},
	async _performSaveInternal() {
		if (!this.name || this.allChapters.length === 0) return;
		
		
		const totalChapters = this.allChapters.length;
		const chapterIndex = this.allChapters[this.currentChapterIndexInAll]?.index;
		if (chapterIndex === undefined) return;
		
		const offsetInChapter = this.currentFileOffset;
		const scrollOffset = this.currentScrollTop;
		const progressPercent = totalChapters > 0 ? parseFloat(((this.currentChapterIndexInAll + 1) / totalChapters * 100).toFixed(2)) : 0;
		
		
		let progress;
		try {
			progress = await bookStorage.get(this.name);
		} catch (e) {
			progress = { chapterIndex: null, offsetInChapter: 0, scrollOffset: 0, bookmarks: [], p: 0 };
		}
		
		progress.chapterIndex = chapterIndex;
		progress.offsetInChapter = offsetInChapter;
		progress.scrollOffset = scrollOffset;
		progress.p = progressPercent;
		
		
		await bookStorage.set(this.name, progress);

		
		this._updateBookshelfAsync(progressPercent);
	},
	_updateBookshelfAsync(progressPercent) {
		
		setTimeout(async () => {
			try {
				const bookshelfUri = 'internal://files/books/bookshelf.json';
				const data = await new Promise((resolve, reject) => {
					file.readText({
						uri: bookshelfUri, 
						success: resolve, 
						fail: reject,
						timeout: 300
					});
				});
				const bookshelf = JSON.parse(data.text);
				const bookIndex = bookshelf.findIndex(b => b.dirName === this.name);
				if (bookIndex > -1) {
					bookshelf[bookIndex].progress = progressPercent;
					await new Promise((resolve, reject) => {
						file.writeText({
							uri: bookshelfUri, 
							text: JSON.stringify(bookshelf), 
							success: resolve, 
							fail: reject,
							timeout: 300
						});
					});
				}
			} catch (e) {
				
			}
		}, 0);
	},
	onHide(){ 
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (autoInterval) { 
			clearInterval(autoInterval); 
			autoInterval = null; 
		}
		
		
		this.saveData(true); 
		
		
		brightness.setKeepScreenOn({ keepScreenOn: false }); 
	},
	onDestroy(){ 
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.timer) {
			clearInterval(this.timer); 
			this.timer = null;
		}
		if (autoInterval) { 
			clearInterval(autoInterval); 
			autoInterval = null; 
		} 
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		
		
		try {
			
			if (this.name && this.allChapters.length > 0) {
				const chapterIndex = this.allChapters[this.currentChapterIndexInAll]?.index;
				if (chapterIndex !== undefined) {
					
					this._performSave().catch(e => {});
				}
			}
		} catch (e) {
			
		}
		
		
		this.page1 = null;
		this.page2 = null;
		this.allChapters = null;
		
		
		brightness.setKeepScreenOn({ keepScreenOn: false }); 
	},
	onBackPress(){ this.back(); return true; },
	back(){
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		if (autoInterval) { 
			clearInterval(autoInterval); 
			autoInterval = null; 
		}
		
		
		this._performSave().catch(e => {});
		
		
		setTimeout(() => {
			router.back();
		}, 100);
	},
	gotoSetting(){
		this.saveData(true);
		router.push({
			uri: '/pages/detailsetting',
			params: { name: this.name }
		});
	},
	async exitAppForTeacherScreen() {
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (autoInterval) {
			clearInterval(autoInterval);
			autoInterval = null;
		}
		
		
		try {
			await Promise.race([
				this._performSave(),
				new Promise(resolve => setTimeout(resolve, 200))
			]);
		} catch (e) {
			
		}
		
		app.terminate();
	},
  	onTxtClick(event) {
		if (this.wait) {
			return;
		}

		if (this.teacherScreenEnabled) {
			this.clickCount++;
			if (this.clickTimeout) {
				clearTimeout(this.clickTimeout);
			}

			if (this.clickCount >= 3) {
				this.clickCount = 0;
				clearTimeout(this.clickTimeout);
				this.clickTimeout = null;
				this.exitAppForTeacherScreen();
				return;
			}

			this.clickTimeout = setTimeout(() => {
				this.clickCount = 0;
				this.clickTimeout = null;
			}, 500);
		}

		if (this.swipe === 'column') { this.showSetting = !this.showSetting; } 
		else {
			if (this.showSetting) { this.showSetting = false; } 
			else {
				if (event.offsetY <= 158) { this.lastPage(); } 
				else if (event.offsetY <= 322) { this.showSetting = !this.showSetting; } 
				else { this.nextPage(); }
			}
		}
	},
	onTxtLongPress(event) {
  		if (this.auto) {
			if(autoInterval){ clearInterval(autoInterval); autoInterval = null; prompt.showToast({ message: '已关闭自动翻页' }); if (!this.isKeepScreenOn) { brightness.setKeepScreenOn({ keepScreenOn: false }); } return; }
			autoInterval = setInterval(() => {
				if (this.isAtChapterEnd) {
					this.goToNextChapter();
				} else {
					this.nextPage();
				}
			}, this.auto*1000);
			prompt.showToast({ message: '已开启自动翻页' });
			brightness.setKeepScreenOn({ keepScreenOn: true });
		}
	},
	lastPage() { this.$element("scrollId").scrollBy({ top: - this.pageHeigh, behavior: 'smooth' }); },
  	nextPage() { this.$element("scrollId").scrollBy({ top: this.pageHeigh, behavior: 'smooth' }); },
	toggleKeepScreenOn() { this.isKeepScreenOn = !this.isKeepScreenOn; brightness.setKeepScreenOn({ keepScreenOn: this.isKeepScreenOn }); prompt.showToast({ message: this.isKeepScreenOn ? '已开启屏幕常亮' : '已关闭屏幕常亮' }); },
	async addBookmark() {
		if (this.longPressTriggered) {
			return;
		}
		
		const progress = await bookStorage.get(this.name);
		if (!progress.bookmarks) { progress.bookmarks = []; }
		
		const chapterIndex = this.allChapters[this.currentChapterIndexInAll].index;
		const newBookmark = { 
			chapterIndex: chapterIndex,
			chapterName: this.currentChapterName,
			offsetInChapter: this.currentFileOffset, 
			scrollOffset: this.currentScrollTop, 
			time: new Date().getTime(), 
			name: `书签${progress.bookmarks.length + 1}` 
		};

		const exists = progress.bookmarks.some(bm => bm.chapterIndex === newBookmark.chapterIndex && bm.offsetInChapter === newBookmark.offsetInChapter);
		if (exists) { prompt.showToast({ message: '书签已存在' }); return; }

		progress.bookmarks.push(newBookmark);
		progress.bookmarks.sort((a, b) => a.chapterIndex - b.chapterIndex || a.offsetInChapter - b.offsetInChapter);
		
		try {
			await bookStorage.set(this.name, progress);
			prompt.showToast({ message: '添加书签成功' });
		} catch (e) {
			prompt.showToast({ message: '添加书签失败' });
		}
	},
	gotoBookmarks() { 
		this.longPressTriggered = true;
		setTimeout(() => {
			this.longPressTriggered = false;
		}, 300);
		this.saveData(true); 
		router.push({ uri: '/pages/bookmarks', params: { name: this.name } }); 
	},
	updateChapterProgress() {
		if (!this.showProgressBar) return;
		if (allSize <= 0) {
			this.chapterProgress = 0;
			return;
		}
		
		
		const progress = (this.currentFileOffset / allSize) * 100;
		this.chapterProgress = Math.min(100, Math.max(0, progress));
	}
	}
  </script>

<style>
.page {
	width: 336px;
	height: 480px;
	background-color: #000000;
}
.progress-bar-container {
	position: absolute;
	bottom: 0px;
	left: 0px;
	width: 336px;
	height: 8px;
	padding: 0 6px;
}
.progress-bar-bg {
	width: 100%;
	height: 4px;
	background-color: rgba(255, 255, 255, 0.2);
	border-radius: 2px;
	overflow: hidden;
}
.progress-bar-fill {
	height: 100%;
	background-color: rgba(255, 255, 255, 0.8);
	border-radius: 2px;
	transition: width 0.1s ease-out;
}
</style>
