<template>
	<div class="page">
	  <scroll id="scrollId"
		style="position: absolute; width: 192px; height: {{scrollHeight}}px; top: {{verticalMargin}}px;"
		scroll-y="{{true}}"
		scroll-top="{{scrollTopValue}}"
		@scroll="onScroll"
		@scrolltop="onScrollTop"
		@scrollbottom="onScrollBottom"
		@click="onTxtClick"
		onlongpress="onTxtLongPress"
		@touchstart="onTouchStart"
		@touchmove="onTouchMove"
		@touchend="onTouchEnd"
		bounces="{{(isAtChapterStart || isAtChapterEnd) && (chapterSwitchStyle == 'boundary')}}"
		>
		<div id="contentContainer" style="position: absolute; width:100%; flex-direction: column;">
			<div if="{{chapterSwitchStyle == 'button' && isAtChapterStart && !showSetting && currentChapterIndexInAll > 0}}" style="width: 100%; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center;" @click="goToPrevChapter">
				<text style="color: #aaa; font-size: 22px; font-weight: bold;">上一章</text>
			</div>
		  <div id="page1" style="flex-direction: column; width: 100%; flex-shrink: 0;">
			<text style="width: 100%; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">{{ page1.text }}</text>
		  </div>
		  <div id="page2" if="{{page2}}" style="flex-direction: column; width: 100%; flex-shrink: 0;">
			<text style="width: 100%; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">{{ page2.text }}</text>
		  </div>
			<div if="{{chapterSwitchStyle == 'button' && isAtChapterEnd && !showSetting && currentChapterIndexInAll < totalChapters - 1}}" style="width: 100%; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center;" @click="goToNextChapter">
				<text style="color: #aaa; font-size: 22px; font-weight: bold;">下一章</text>
			</div>
		</div>
	  </scroll>
		<img show="{{showSetting}}" src="/common/images/hd.png" style="position: absolute;left: 0px;top: 0px;width: 192px;height: 132px;" />
		<text show="{{showSetting}}" style="position: absolute;left: 44px;top: 12px;width: 104px;line-height: 32px;font-weight:bold;font-size:20px;color:rgba(255,255,255,0.6);text-align:center;">
			{{nowTime}}
		</text>
		<marquee show="{{showSetting}}" scrollamount="40" text-offset="25" style="position: absolute;left: 24px;top: 40px;width: 144px;line-height: 42px;font-weight:bold;font-size:28px;color:white;text-align:center;">
			{{currentChapterName}}
		</marquee>

		<img show="{{showSetting}}" src="/common/images/bt.png" style="position: absolute;left: 0px;top: 288px;width: 192px;height: 202px;" />
		<img show="{{showSetting}}" src="/common/images/more.png" @click="gotoSetting" style="position: absolute;bottom: 6px;left:60px;width: 72px;height: 72px;"/>
		<div show="{{showSetting}}" style="position: absolute; top: 372px; left: 16px; width: 180px; height: 72px; flex-direction: column; justify-content: flex-start; align-items: center;">
			<text style="line-height: 42px;font-weight:bold;font-size:26px;color:white;text-align:center;">
				{{currentPage}} / {{totalPages}}
			</text>
			<text style="line-height: 32px;font-weight:bold;font-size:20px;color:rgba(255,255,255,0.6);text-align:center;">
				阅读进度
			</text>
		</div>
		
	</div>
  </template>

  <script>
	import prompt from '@system.prompt'
	import file from '@system.file'
	import router from '@system.router'
    import storage from '../../common/storage.js'
	import bookStorage from '../../common/bookStorage.js'
	import chapterManager from '../../common/chapterManager.js'
	import brightness from '@system.brightness'
	import app from '@system.app'

	let allSize = 0;
    let autoInterval = null;

	export default {
	  private: {
		txtSizePage: 400,
		fontSize: 30,
		lineHeight: 34,
		pageHeigh: 480,
		verticalMargin: 10,
		scrollHeight: 480,
		showSetting: true,
		loadingNext: false,
		loadingPrev: false,
		page1: { text: "加载中...", offset: 0, length: 0 },
		page2: null,
		currentFileOffset: 0,
		opacity: 100,
		swipe: 'column',
		auto: false,
		nowTime: "00:00",
		timer: null,
		savedScrollOffset: 0,
      	currentScrollTop: 0,
		totalPages: 0,
		currentPage: 0,
		isKeepScreenOn: false,
		currentChapterIndexInAll: 0,
		currentChapterName: "",
		cPath: "",
		isAtChapterEnd: false,
		isAtChapterStart: false,
		scrollTopValue: 0,
		wait: false,
		longPressTriggered: false,
		saveDataTimeout: null,
		totalChapters: 0,
		teacherScreenEnabled: false,
		clickCount: 0,
		clickTimeout: null,
		gestureMode: 'single',
		gestureClickCount: 0,
		gestureClickTimeout: null,
		chapterSwitchHeight: 80,
		chapterSwitchSensitivity: 50,
		swipeSensitivity: 80,
		chapterSwitchStyle: 'button',
		touchStartY: 0,
		overscrollDistance: 0,
		isTouching: false,
		bounces: false,
		touchStartX: 0,
		touchEndX: 0,
		isInitialized: false,
		longPressTimeout: null,
		isProcessingClick: false,
		autoReadDistance: 100,
        timeFormat: '24h',
		contentHeight: 0,
		preventParagraphSplitting: false,
	  },
	  protected: {
		name: '',
		chapterIndex: -1,
		chapterName: ''
	  },
	  updateTime() {
		const date = new Date();
		let hours = date.getHours();
		let minutes = date.getMinutes();
        if (this.timeFormat === '12h') {
            let ampm = hours >= 12 ? '下午' : '上午';
            hours = hours % 12;
            hours = hours ? hours : 12;
            minutes = minutes < 10 ? '0' + minutes : minutes;
            this.nowTime = `${ampm} ${hours}:${minutes}`;
        } else {
            hours = hours < 10 ? '0' + hours : hours;
            minutes = minutes < 10 ? '0' + minutes : minutes;
            this.nowTime = `${hours}:${minutes}`;
        }
	 },
	updatePageNumber(){
		this.currentPage = this.currentChapterIndexInAll + 1;
		this.totalPages = this.totalChapters;
	},
	onInit(){
		this.updateTime();
		this.timer = setInterval(() => { this.updateTime(); }, 1000);
		globalThis.isKeepScreenOn = this.isKeepScreenOn;
	},
	async onShow(){
		this.loadSettings();
		if (typeof globalThis.isKeepScreenOn !== 'undefined') {
			if (this.isKeepScreenOn !== globalThis.isKeepScreenOn) {
				this.isKeepScreenOn = globalThis.isKeepScreenOn;
				brightness.setKeepScreenOn({ keepScreenOn: this.isKeepScreenOn });
				prompt.showToast({ message: this.isKeepScreenOn ? '已开启屏幕常亮' : '已关闭屏幕常亮' });
			}
		}
		storage.get({
			key: 'EBOOK_TEACHER_SCREEN_ENABLED',
			success: (data) => {
				this.teacherScreenEnabled = data === 'true';
			}
		});
		const isChapterJump = globalThis.justJumpedFromChapter || globalThis.justJumpedFromBookmark || globalThis.justJumpedFromPageNumber;
        if (!this.isInitialized || isChapterJump) {
            if(globalThis.justJumpedFromChapter) {
			    this.chapterIndex = globalThis.newChapterIndex;
			    this.chapterName = globalThis.newChapterName;
                delete globalThis.newChapterIndex;
			    delete globalThis.newChapterName;
            }
			await this.loadBook();
            this.isInitialized = true;
        }
	},
	loadSettings() {
		const settings = [
			{ key: 'EBOOK_TXTSZPAGE', type: 'int', prop: 'txtSizePage' },
			{ key: 'EBOOK_VERTICAL_MARGIN', type: 'int', prop: 'verticalMargin', callback: this.updateScrollHeight },
			{ key: 'EBOOK_FONT', type: 'int', prop: 'fontSize', callback: () => { 
				this.lineHeight = parseInt((-0.01)*(this.fontSize**2) + 1.62*this.fontSize - 3.23);
				this.updateScrollHeight();
			}},
			{ key: 'EBOOK_OPACITY', type: 'int', prop: 'opacity' },
			{ key: 'EBOOK_SWIPE', type: 'string', prop: 'swipe' },
			{ key: 'EBOOK_AUTO', type: 'json', prop: 'auto', process: (data) => { if (data && data.enable) return data.speed; }},
			{ key: 'EBOOK_GESTURE', type: 'string', prop: 'gestureMode', defaultValue: 'single' },
			{ key: 'EBOOK_CHAPTER_SWITCH_HEIGHT', type: 'int', prop: 'chapterSwitchHeight' },
			{ key: 'EBOOK_CHAPTER_SWITCH_SENSITIVITY', type: 'int', prop: 'chapterSwitchSensitivity' },
			{ key: 'EBOOK_SWIPE_SENSITIVITY', type: 'int', prop: 'swipeSensitivity' },
			{ key: 'EBOOK_CHAPTER_SWITCH_STYLE', type: 'string', prop: 'chapterSwitchStyle', defaultValue: 'button' },
			{ key: 'EBOOK_AUTO_READ_DISTANCE', type: 'int', prop: 'autoReadDistance', defaultValue: 100 },
			{ key: 'EBOOK_PREVENT_PARAGRAPH_SPLITTING', type: 'bool', prop: 'preventParagraphSplitting' }
		];

        storage.get({
            key: 'EBOOK_TIME_FORMAT',
            success: (data) => {
                if(data) this.timeFormat = data;
            }
        });
	
		let index = 0;
		const loadNextSetting = () => {
			if (index >= settings.length) return;
	
			const setting = settings[index];
			storage.get({
				key: setting.key,
				success: (data) => {
					if (data !== null && data !== '') {
						switch (setting.type) {
							case 'int':
								this[setting.prop] = parseInt(data);
								break;
							case 'bool':
								this[setting.prop] = data === 'true';
								break;
							case 'json':
								const parsedData = JSON.parse(data);
								const processedData = setting.process ? setting.process(parsedData) : parsedData;
								if (processedData) this[setting.prop] = processedData;
								break;
							default:
								this[setting.prop] = data;
								break;
						}
					} else if (setting.defaultValue) {
						this[setting.prop] = setting.defaultValue;
					}
					if (setting.callback) setting.callback();
				},
				fail: () => {
					if (setting.defaultValue) {
						this[setting.prop] = setting.defaultValue;
						if (setting.callback) setting.callback();
					}
				},
				complete: () => {
					index++;
					loadNextSetting();
				}
			});
		};
	
		loadNextSetting();
	},
	updateContentHeight() {
		setTimeout(() => {
			this.$element("contentContainer").getBoundingClientRect({
				success: (rect) => {
					this.contentHeight = rect.height;
				}
			});
		}, 50);
	},
	updateScrollHeight() {
		this.scrollHeight = 480 - this.verticalMargin * 2;
		this.pageHeigh = Math.floor(this.scrollHeight/this.lineHeight) * this.lineHeight;
	},
	async loadBook() {
		const progress = await bookStorage.get(this.name);
		let chapterToLoadIndex;
		let offsetInChapter = 0;
		let scrollOffset = 0;
		let fromChapterJump = false;

		if (globalThis.justJumpedFromChapter) {
			fromChapterJump = true;
			chapterToLoadIndex = this.chapterIndex;
			this.currentChapterName = this.chapterName;
			offsetInChapter = 0;
			scrollOffset = 0;
			globalThis.justJumpedFromChapter = false;
		} else if (globalThis.justJumpedFromBookmark || globalThis.justJumpedFromPageNumber) {
			chapterToLoadIndex = progress.chapterIndex;
			offsetInChapter = progress.offsetInChapter || 0;
			scrollOffset = progress.scrollOffset || 0;
			globalThis.justJumpedFromBookmark = false;
			globalThis.justJumpedFromPageNumber = false;
		} else if (progress.chapterIndex !== null) {
			chapterToLoadIndex = progress.chapterIndex;
			offsetInChapter = progress.offsetInChapter || 0;
			scrollOffset = progress.scrollOffset || 0;
		} else {
			chapterToLoadIndex = 0;
		}

		const chapterInfo = await chapterManager.getChapterInfo(this.name, chapterToLoadIndex);

		if (!chapterInfo || !chapterInfo.chapter) {
			this.page1 = { text: "本书没有内容", offset: 0, length: 0 };
			return;
		}

		this.totalChapters = chapterInfo.totalChapters;
		const chapterArrayIndex = chapterInfo.chapterArrayIndex;
		
		this.currentFileOffset = offsetInChapter;
		this.savedScrollOffset = scrollOffset;
		this.scrollTopValue = scrollOffset;
		this.currentScrollTop = scrollOffset;

		this.loadChapter(chapterArrayIndex, () => {
			this.loadInitialSegments();
			if (fromChapterJump) {
				this.isAtChapterStart = false;
			} else {
				this.isAtChapterStart = this.currentFileOffset === 0 && this.savedScrollOffset < 10;
			}
		});
	},
	async loadChapter(chapterIdxInAll, callback) {
		if (chapterIdxInAll < 0) {
			if(callback) callback();
			return;
		}

		const chapter = await chapterManager.getChapterByArrayIndex(this.name, chapterIdxInAll);
		if (!chapter) {
			if(callback) callback();
			return;
		}
		
		if (this.page1) {
			this.page1.text = null;
			this.page1 = null;
		}
		if (this.page2) {
			this.page2.text = null;
			this.page2 = null;
		}
		
		this.page1 = { text: "", offset: 0, length: 0 };
		this.page2 = null;
		
		this.isAtChapterStart = false;
		this.isAtChapterEnd = false;
		this.currentChapterIndexInAll = chapterIdxInAll;
		this.currentChapterName = chapter.name;
		this.cPath = `internal://files/books/${this.name}/content/${chapter.index}.txt`;

		file.get({
			uri: this.cPath,
			success: (data) => {
				allSize = data.length;
				this.updatePageNumber();
				if(callback) callback();
			},
			fail: (data, code) => {
				allSize = 0;
                prompt.showToast({ message: `加载章节失败: ${code}` });
				if(callback) callback();
			}
		});
	},
	loadInitialSegments(){
		var that = this;
		this.wait = true;
		this.readFileText(this.currentFileOffset, function(str, bytesRead){
		  that.page1 = { text: str, offset: that.currentFileOffset, length: bytesRead };
		  that.loadNextSegmentNoScroll();
		  that.updateContentHeight();
		});
	},
	loadNextSegmentNoScroll(){
		var that = this;
		let newOffset = that.page1.offset + that.page1.length;
		if(newOffset >= allSize) {
			that.isAtChapterEnd = true;
			that.page2 = null;
			that.restoreScrollPosition();
			return;
		}
	
		that.readFileText(newOffset, function(str, bytesRead){
			if(str){
				that.page2 = { text: str, offset: newOffset, length: bytesRead };
			} else {
				that.page2 = null;
			}
			that.restoreScrollPosition();
			that.updateContentHeight();
		});
	},
	restoreScrollPosition() {
		setTimeout(() => {
			this.scrollTopValue = this.savedScrollOffset;
			this.currentScrollTop = this.savedScrollOffset;
			this.wait = false;
			this.saveData(true);
		}, 50);
	},
	readFileText(readOffset, cb){
		if(readOffset >= allSize){ cb('', 0); return; }
		var length = this.txtSizePage * 2;
		if(readOffset < 0){ length += readOffset; readOffset = 0; }
		
		let actualLength = length;
		if((readOffset + actualLength) >= allSize){ 
			actualLength = allSize - readOffset; 
		}

		const isPotentiallyPartial = (readOffset + actualLength) < allSize;

		let readLength = actualLength;
		if (isPotentiallyPartial) {
			readLength += 300;
			if (readOffset + readLength > allSize) {
				readLength = allSize - readOffset;
			}
		}
		
		file.readArrayBuffer({
		  uri: this.cPath, position: readOffset, length: readLength,
		  success: function(data){
			if (!data.buffer || data.buffer.length === 0) {
				cb('', 0);
				return;
			}
			try {
				const charCodes = new Uint16Array(data.buffer.length / 2);
				for (let i = 0, j = 0; i < data.buffer.length; i += 2, j++) {
					charCodes[j] = (data.buffer[i+1] << 8) | data.buffer[i];
				}

				let str = '';
				const CHUNK_SIZE = 8192;
				for (let i = 0; i < charCodes.length; i += CHUNK_SIZE) {
					str += String.fromCharCode.apply(null, charCodes.subarray(i, i + CHUNK_SIZE));
				}
				
				if (!isPotentiallyPartial) {
					cb(str, actualLength);
					return;
				}
				
				let cutLength = actualLength / 2;
				if(cutLength > str.length) cutLength = str.length;

				const chunk = str.substring(0, cutLength);
				
				if (this.preventParagraphSplitting) {
					const lastNewlineIndex = chunk.lastIndexOf('\n');
					if (lastNewlineIndex > 0) {
						const finalStr = chunk.substring(0, lastNewlineIndex + 1);
						const bytesToReport = finalStr.length * 2;
						cb(finalStr, bytesToReport);
						return;
					}
				}
				
				cb(chunk, chunk.length * 2);
			} catch (e) {
				prompt.showToast({ message: `解码章节内容失败: ${e}` });
				cb('', 0);
			}
		  },
		  fail: function(){ cb('', 0); }
		});
	},
	onScroll(e){
		if (this.wait) return;

		if (this.isAtChapterEnd && e.scrollY < this.currentScrollTop) {
			this.isAtChapterEnd = false;
		}
		this.currentScrollTop = e.scrollY;
		this.isAtChapterStart = this.currentFileOffset === 0 && this.currentScrollTop < 10;
		this.saveData();

		if (this.contentHeight > this.scrollHeight) {
			const isNearBottom = this.currentScrollTop >= (this.contentHeight - this.scrollHeight - this.chapterSwitchSensitivity);
			if (isNearBottom) {
				let lastSeg = this.page2 || this.page1;
				let newOffset = lastSeg.offset + lastSeg.length;
				if(newOffset >= allSize) {
					this.isAtChapterEnd = true;
				}
			}
		}
	},
	onScrollTop(){
		if (this.wait) return;
		if (this.currentFileOffset > 0) {
			if(!this.loadingPrev){ this.loadingPrev = true; this.loadPrevSegment(); }
		}
	},
	onScrollBottom(){
		if (this.wait) return;
		if(!this.loadingNext){ this.loadingNext = true; this.loadNextSegment(); }
	},
	loadNextSegment(){
		this.wait = true;
		var that = this;
		let lastSeg = that.page2 || that.page1;
		let newOffset = lastSeg.offset + lastSeg.length;

		if(newOffset >= allSize) {
			that.loadingNext = false;
			that.isAtChapterEnd = true;
			that.wait = false;
			return;
		}

		this.readFileText(newOffset, function (str, bytesRead) {
			that.loadingNext = false;
			if(str){
				const nextPageData = { text: str, offset: newOffset, length: bytesRead };
				that.shiftPagesForward(nextPageData);
			} else {
				that.wait = false;
			}
		});
	},
	shiftPagesForward(nextPageData) {
		var that = this;
		const scrollPosBeforeLoad = this.currentScrollTop;
		that.$element("page1").getBoundingClientRect({
			success: function(rect){
				let removedHeight = rect.height;
				
				
				if (that.page1 && that.page1 !== that.page2) {
					that.page1.text = null;
				}
				
				that.page1 = that.page2 || that.page1;
				that.page2 = nextPageData;
				
				const newScrollPos = scrollPosBeforeLoad - removedHeight + that.lineHeight;
				that.scrollTopValue = newScrollPos;
				that.currentScrollTop = newScrollPos;

				that.currentFileOffset = that.page1.offset;
				that.saveData(true);
				that.wait = false;
				that.updateContentHeight();
			},
			fail: function() {
				that.wait = false;
			}
		});
	},
	loadPrevSegment(){
		this.wait = true;
		var that = this;
		if(that.page1.offset <= 0){
			this.wait = false;
			this.loadingPrev = false;
			return;
		}

		let newOffset = that.page1.offset - this.txtSizePage * 2;
		if(newOffset < 0) newOffset = 0;

		this.readFileText(newOffset, function (str, bytesRead) {
			that.loadingPrev = false;
			if(str){
				const prevPageData = { text: str, offset: newOffset, length: bytesRead };
				
				
				if (that.page2) {
					that.page2.text = null;
				}
				
				that.page2 = that.page1;
				that.page1 = prevPageData;
				that.$element("page1").getBoundingClientRect({
					success: function(rect){
						const newScrollPos = that.currentScrollTop + rect.height;
						that.scrollTopValue = newScrollPos;
						that.currentScrollTop = newScrollPos;
						that.currentFileOffset = that.page1.offset;
						that.saveData(true);
						that.wait = false;
						that.updateContentHeight();
					},
					fail: function() {
						that.wait = false;
					}
				});
			} else {
				that.wait = false;
			}
		});
	},
	onTouchStart(e) {
		this.isTouching = true;
		this.touchStartY = e.touches[0].clientY;
		this.overscrollDistance = 0;
		if (this.chapterSwitchStyle === 'swipe') {
			this.touchStartX = e.touches[0].clientX;
			this.touchEndX = e.touches[0].clientX;
		}
	},
	onTouchMove(e) {
		if (!this.isTouching) return;

		if (this.chapterSwitchStyle === 'boundary') {
			const currentY = e.touches[0].clientY;
			const deltaY = currentY - this.touchStartY;

			if (this.isAtChapterStart && deltaY > 0) {
				this.overscrollDistance = deltaY;
			} else if (this.isAtChapterEnd && deltaY < 0) {
				this.overscrollDistance = -deltaY;
			} else {
				this.overscrollDistance = 0;
			}
		} else if (this.chapterSwitchStyle === 'swipe') {
			this.touchEndX = e.touches[0].clientX;
		}
	},
	onTouchEnd(e) {
		if (!this.isTouching) return;
		this.isTouching = false;
		
		if (this.chapterSwitchStyle === 'boundary') {
			if (this.overscrollDistance > this.chapterSwitchSensitivity) {
				if (this.isAtChapterStart) {
					this.goToPrevChapter();
				} else if (this.isAtChapterEnd) {
					this.goToNextChapter();
				}
			}
			this.overscrollDistance = 0;
			this.touchStartY = 0;
		} else if (this.chapterSwitchStyle === 'swipe') {
			if (this.touchStartX === 0) return;
			const deltaX = this.touchEndX - this.touchStartX;
			if (Math.abs(deltaX) > this.swipeSensitivity) {
				if (deltaX > 0) {
					this.goToPrevChapter();
				} else {
					this.goToNextChapter();
				}
			}
			this.touchStartX = 0;
			this.touchEndX = 0;
		}
	},
	goToPrevChapter() {
		if (this.wait) return;
		this.wait = true;

		const prevChapterIndex = this.currentChapterIndexInAll - 1;
		if (prevChapterIndex < 0) {
			prompt.showToast({ message: '已是第一章' });
			this.wait = false;
			return;
		}
		
		this.isAtChapterEnd = false;

		this.loadChapter(prevChapterIndex, () => {
			this.loadLastSegmentsAndScrollToEnd();
		});
	},
	loadLastSegmentsAndScrollToEnd() {
        const that = this;
        this.wait = true;

        let offset2 = Math.max(0, allSize - (this.txtSizePage * 2));
        let offset1 = Math.max(0, offset2 - (this.txtSizePage * 2));
        
        if (offset1 === offset2 && allSize > 0) {
            offset1 = 0;
            offset2 = -1;
        } else if (offset1 === offset2) {
            this.page1 = { text: "", offset: 0, length: 0 };
            this.page2 = null;
            this.isAtChapterEnd = true;
            this.isAtChapterStart = true;
            this.wait = false;
            return;
        }

        this.currentFileOffset = offset1;

        this.readFileText(offset1, function(str1, bytesRead1) {
            that.page1 = { text: str1, offset: offset1, length: bytesRead1 };

            if (offset2 === -1 || offset2 >= allSize) {
                that.page2 = null;
                that.isAtChapterEnd = true;
                that.scrollToEnd();
				that.updateContentHeight();
                return;
            }

            that.readFileText(offset2, function(str2, bytesRead2) {
                if (str2) {
                    that.page2 = { text: str2, offset: offset2, length: bytesRead2 };
                } else {
                    that.page2 = null;
                }
                that.isAtChapterEnd = true;
                that.scrollToEnd();
				that.updateContentHeight();
            });
        });
    },
    scrollToEnd() {
        setTimeout(() => {
            this.$element("contentContainer").getBoundingClientRect({
                success: (rect) => {
                    const contentHeight = rect.height;
                    const scrollPos = contentHeight - this.scrollHeight;
                    const finalScrollTop = scrollPos > 0 ? scrollPos : 0;

                    this.scrollTopValue = finalScrollTop - 1;

                    setTimeout(() => {
                        this.scrollTopValue = finalScrollTop;
                        this.currentScrollTop = finalScrollTop;
                        this.wait = false;
                        this.isAtChapterStart = this.scrollTopValue < 10 && this.currentFileOffset === 0;
                        this.saveData(true);
                    }, 50);
                },
                fail: () => {
                    this.wait = false;
                }
            });
        }, 150);
    },
	goToNextChapter() {
		if (this.wait) return;
		this.wait = true;
	
		const nextChapterIndex = this.currentChapterIndexInAll + 1;
		if (nextChapterIndex >= this.totalChapters) {
			prompt.showToast({ message: '已是最后一章' });
			if (autoInterval) {
				clearInterval(autoInterval);
				autoInterval = null;
				prompt.showToast({ message: '已关闭自动翻页' });
				if (!this.isKeepScreenOn) {
					brightness.setKeepScreenOn({ keepScreenOn: false });
				}
			}
			this.wait = false;
			return;
		}
		
		this.isAtChapterEnd = false;
		this.currentFileOffset = 0;
		this.savedScrollOffset = 0;
		this.scrollTopValue = 0;
		this.currentScrollTop = 0;
		
		this.loadChapter(nextChapterIndex, () => {
			this.page1 = { text: "加载中...", offset: 0, length: 0 };
			this.page2 = null;
			this.loadInitialSegments();
			this.isAtChapterStart = false;
			this.saveData(true);
		});
	},
	saveData(forceImmediate = false){
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (forceImmediate) {
			this._performSave();
		} else {
			this.saveDataTimeout = setTimeout(() => {
				this._performSave();
			}, 2000);
		}
	},
	async _performSave() {
		if (!this.name || this.totalChapters === 0) return;
		
		try {
			
			const savePromise = this._performSaveInternal();
			const timeoutPromise = new Promise((resolve) => setTimeout(resolve, 500));
			await Promise.race([savePromise, timeoutPromise]);
		} catch (e) {
			// console.error('Save failed:', e);
		}
	},
	async _performSaveInternal() {
		if (!this.name || this.totalChapters === 0) return;
		
		const chapter = await chapterManager.getChapterByArrayIndex(this.name, this.currentChapterIndexInAll);
		if (!chapter) return;
		
		const totalChapters = this.totalChapters;
		const chapterIndex = chapter.index;
		if (chapterIndex === undefined) return;
		
		const offsetInChapter = this.currentFileOffset;
		const scrollOffset = this.currentScrollTop;

		let progressPercent = 0;
		progressPercent = totalChapters > 0 ? parseFloat(((this.currentChapterIndexInAll + 1) / totalChapters * 100).toFixed(2)) : 0;
		
		let progress;
		try {
			progress = await bookStorage.get(this.name);
		} catch (e) {
			progress = { chapterIndex: null, offsetInChapter: 0, scrollOffset: 0, bookmarks: [], p: 0 };
		}
		
		progress.chapterIndex = chapterIndex;
		progress.offsetInChapter = offsetInChapter;
		progress.scrollOffset = scrollOffset;
		progress.p = progressPercent;
		
		
		await bookStorage.set(this.name, progress);

		
		this._updateBookshelfAsync(progressPercent);
	},
	_updateBookshelfAsync(progressPercent) {
		
		setTimeout(async () => {
			try {
				const bookshelfUri = 'internal://files/books/bookshelf.json';
				const data = await new Promise((resolve, reject) => {
					file.readText({
						uri: bookshelfUri, 
						success: resolve, 
						fail: reject,
						timeout: 300
					});
				});
				const bookshelf = JSON.parse(data.text);
				const bookIndex = bookshelf.findIndex(b => b.dirName === this.name);
				if (bookIndex > -1) {
					bookshelf[bookIndex].progress = progressPercent;
					await new Promise((resolve, reject) => {
						file.writeText({
							uri: bookshelfUri, 
							text: JSON.stringify(bookshelf), 
							success: resolve, 
							fail: reject,
							timeout: 300
						});
					});
				}
			} catch (e) {
				
			}
		}, 0);
	},
	onHide(){ 
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (autoInterval) { 
			clearInterval(autoInterval); 
			autoInterval = null; 
		}
		
		
		this.saveData(true); 
		
		
		brightness.setKeepScreenOn({ keepScreenOn: false }); 
	},
	async onDestroy(){ 
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.timer) {
			clearInterval(this.timer); 
			this.timer = null;
		}
		if (autoInterval) { 
			clearInterval(autoInterval); 
			autoInterval = null; 
		} 
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		if (this.gestureClickTimeout) {
			clearTimeout(this.gestureClickTimeout);
			this.gestureClickTimeout = null;
		}
		if (this.longPressTimeout) {
			clearTimeout(this.longPressTimeout);
			this.longPressTimeout = null;
		}
		
		
		try {
			
			if (this.name && this.totalChapters > 0) {
				const chapter = await chapterManager.getChapterByArrayIndex(this.name, this.currentChapterIndexInAll);
				if (chapter && chapter.index !== undefined) {
					
					this._performSave().catch(e => {});
				}
			}
		} catch (e) {
			
		}
		
		
		this.page1 = null;
		this.page2 = null;
		
		
		brightness.setKeepScreenOn({ keepScreenOn: false }); 

		if (typeof global !== 'undefined' && typeof global.runGC === 'function') {
			global.runGC();
		}
	},
	onBackPress(){ this.back(); return true; },
	back(){
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		if (this.gestureClickTimeout) {
			clearTimeout(this.gestureClickTimeout);
			this.gestureClickTimeout = null;
		}
		if (this.longPressTimeout) {
			clearTimeout(this.longPressTimeout);
			this.longPressTimeout = null;
		}
		if (autoInterval) { 
			clearInterval(autoInterval); 
			autoInterval = null; 
		}
		
		
		this._performSave().catch(e => {});
		
		
		setTimeout(() => {
			router.back();
		}, 100);
	},
	gotoSetting(){
		if (this.isProcessingClick) return;
		this.isProcessingClick = true;
		this.saveData(true);
		globalThis.isKeepScreenOn = this.isKeepScreenOn;
		router.push({
			uri: '/pages/detailsetting',
			params: { name: this.name }
		});
		setTimeout(() => { this.isProcessingClick = false; }, 500);
	},
	async exitAppForTeacherScreen() {
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (autoInterval) {
			clearInterval(autoInterval);
			autoInterval = null;
		}
		
		
		try {
			await Promise.race([
				this._performSave(),
				new Promise(resolve => setTimeout(resolve, 200))
			]);
		} catch (e) {
			
		}
		
		app.terminate();
	},
  	onTxtClick(event) {
		if (this.wait) return;

		if (this.teacherScreenEnabled) {
			this.clickCount++;
			if (this.clickTimeout) {
				clearTimeout(this.clickTimeout);
			}

			if (this.clickCount >= 3) {
				this.clickCount = 0;
				clearTimeout(this.clickTimeout);
				this.clickTimeout = null;
				this.exitAppForTeacherScreen();
				return;
			}

			this.clickTimeout = setTimeout(() => {
				this.clickCount = 0;
				this.clickTimeout = null;
			}, 500);
		}

		const handleUIToggle = () => {
			this.showSetting = !this.showSetting;
		}

		if (this.gestureMode === 'double') {
			this.gestureClickCount++;
			if (this.gestureClickTimeout) {
				clearTimeout(this.gestureClickTimeout);
				this.gestureClickTimeout = null;
			}
			if (this.gestureClickCount === 2) {
				this.gestureClickCount = 0;
				this.gestureClickTimeout = null;
				handleUIToggle();
			} else {
				this.gestureClickTimeout = setTimeout(() => {
					this.gestureClickCount = 0;
					this.gestureClickTimeout = null;
					if (this.swipe !== 'column') {
						if (this.showSetting) {
							this.showSetting = false;
						} else {
							if (event.offsetY <= 158) { this.lastPage(); }
							else if (event.offsetY > 322) { this.nextPage(); }
						}
					}
				}, 300);
			}
		} else { // single click mode
			if (this.swipe === 'column') {
				handleUIToggle();
			} else {
				if (this.showSetting) {
					handleUIToggle();
				} else {
					if (event.offsetY <= 158) { this.lastPage(); }
					else if (event.offsetY <= 322) { handleUIToggle(); }
					else { this.nextPage(); }
				}
			}
		}
	},
	onTxtLongPress(event) {
  		if (this.auto) {
			if(autoInterval){ clearInterval(autoInterval); autoInterval = null; prompt.showToast({ message: '已关闭自动翻页' }); if (!this.isKeepScreenOn) { brightness.setKeepScreenOn({ keepScreenOn: false }); } return; }
			autoInterval = setInterval(() => {
				if (this.isAtChapterEnd) {
					this.goToNextChapter();
				} else {
					this.nextPage();
				}
			}, this.auto*1000);
			prompt.showToast({ message: '已开启自动翻页' });
			brightness.setKeepScreenOn({ keepScreenOn: true });
		}
	},
	lastPage() { this.$element("scrollId").scrollBy({ top: - (this.pageHeigh * (this.autoReadDistance / 100)), behavior: 'smooth' }); },
  	nextPage() { this.$element("scrollId").scrollBy({ top: (this.pageHeigh * (this.autoReadDistance / 100)), behavior: 'smooth' }); },
	}
  </script>

<style>
.page {
	width: 192px;
	height: 490px;
	background-color: #000000;
}
</style>
