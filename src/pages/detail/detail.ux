<template>
	<div class="page" style="background-color: rgb({{bgR}},{{bgG}},{{bgB}});">
	  <scroll id="scrollId"
		style="position: absolute; width: 192px; height: {{scrollHeight}}px; top: {{verticalMargin}}px;"
		scroll-y="{{true}}"
		scroll-top="{{scrollTopValue}}"
		@scroll="onScroll"
		@scrolltop="onScrollTop"
		@scrollbottom="onScrollBottom"
		@click="onTxtClick"
		onlongpress="onTxtLongPress"
		@touchstart="onTouchStart"
		@touchmove="onTouchMove"
		@touchend="onTouchEnd"
		bounces="{{(isAtChapterStart || isAtChapterEnd) && (chapterSwitchStyle == 'boundary')}}"
		>
		<div id="contentContainer" style="position: absolute; width:100%; flex-direction: column;">
			<div if="{{chapterSwitchStyle == 'button' && isAtChapterStart && !showSetting && currentChapterIndexInAll > 0}}" style="width: 100%; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center;" @click="goToPrevChapter">
				<text style="color: #aaa; font-size: 22px; font-weight: bold;">上一章</text>
			</div>
		  <div id="page1" style="flex-direction: column; width: 100%; flex-shrink: 0;">
			<text style="width: 100%; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">{{ page1.text }}</text>
		  </div>
		  <div id="page2" if="{{page2}}" style="flex-direction: column; width: 100%; flex-shrink: 0;">
			<text style="width: 100%; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">{{ page2.text }}</text>
		  </div>
			<div if="{{chapterSwitchStyle == 'button' && isAtChapterEnd && !showSetting && currentChapterIndexInAll < totalChapters - 1}}" style="width: 100%; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center;" @click="goToNextChapter">
				<text style="color: #aaa; font-size: 22px; font-weight: bold;">下一章</text>
			</div>
		</div>
	  </scroll>
	  <img show="{{showSetting || (alwaysShowTime && !isNearTopForHd)}}" src="/common/images/hd.png" style="position: absolute;left: 0px;top: 0px;width: 192px;height: 132px;" />
	  <text show="{{showSetting || (alwaysShowTime && !isNearTopForHd)}}" style="position: absolute;left: 44px;top: 12px;width: 104px;line-height: 32px;font-weight:bold;font-size:20px;color:rgba(255,255,255,0.6);text-align:center;">
			{{nowTime}}
		</text>
		<marquee show="{{showSetting}}" scrollamount="40" text-offset="25" style="position: absolute;left: 24px;top: 40px;width: 144px;line-height: 42px;font-weight:bold;font-size:28px;color:white;text-align:center;">
			{{currentChapterName}}
		</marquee>

		<img show="{{showSetting}}" src="/common/images/bt.png" style="position: absolute;left: 0px;top: 288px;width: 192px;height: 202px;" />
		<img show="{{showSetting}}" src="/common/images/more.png" @click="gotoSetting" style="position: absolute;bottom: 6px;left:60px;width: 72px;height: 72px;"/>
		<div show="{{showSetting}}" style="position: absolute; top: 342px; left: 6px; width: 180px; height: 72px; flex-direction: column; justify-content: flex-start; align-items: center;">
			<text style="line-height: 42px;font-weight:bold;font-size:26px;color:white;text-align:center;">
				{{currentPage}} / {{totalPages}}
			</text>
			<text style="line-height: 32px;font-weight:bold;font-size:20px;color:rgba(255,255,255,0.6);text-align:center;">
				阅读进度
			</text>
		</div>
		
	</div>
  </template>
  <script>
  import prompt from '@system.prompt'
  import file from '@system.file'
  import router from '@system.router'
  import storage from '../../utils/storage.js'
  import bookStorage from '../../utils/bookStorage.js'
  import chapterManager from '../../utils/chapterManager.js'
  import brightness from '@system.brightness'
  import app from '@system.app'
  import readingTimeStorage from '../../utils/readingTimeStorage.js'
  import battery from '@system.battery'
  export default {
	allSize: 0,
	autoInterval: null,
	cPath: "",
	private: {
	  txtSizePage: 400,
	  fontSize: 24,
	  lineHeight: 34,
	  pageHeigh: 514,
	  verticalMargin: 20,
	  scrollHeight: 514,
	  showSetting: true,
	  loadingNext: false,
	  loadingPrev: false,
	  page1: { text: "加载中...", offset: 0, length: 0 },
	  page2: null,
	  currentFileOffset: 0,
	  opacity: 100,
	  swipe: 'column',
	  auto: false,
	  nowTime: "00:00",
	  batteryLevel: "",
	  timer: null,
	  timeCounter: 0,
	  savedScrollOffset: 0,
	  currentScrollTop: 0,
	  totalPages: 0,
	  currentPage: 0,
	  isKeepScreenOn: false,
	  currentChapterIndexInAll: 0,
	  currentChapterName: "",
	  isAtChapterEnd: false,
	  isAtChapterStart: false,
	  scrollTopValue: 0,
	  wait: false,
	  longPressTriggered: false,
	  saveDataTimeout: null,
	  totalChapters: 0,
	  teacherScreenEnabled: false,
	  clickCount: 0,
	  clickTimeout: null,
	  chapterProgress: 0,
	  gestureMode: 'single',
	  gestureClickCount: 0,
	  gestureClickTimeout: null,
	  chapterSwitchHeight: 80,
	  chapterSwitchSensitivity: 50,
	  swipeSensitivity: 80,
	  chapterSwitchStyle: 'button',
	  touchStartY: 0,
	  overscrollDistance: 0,
	  isTouching: false,
	  touchStartX: 0,
	  touchEndX: 0,
	  nostalgicTouchStartX: 0,
	  nostalgicTouchStartY: 0,
	  nostalgicTouchEndX: 0,
	  nostalgicTouchEndY: 0,
	  nostalgicIsTouching: false,
	  isInitialized: false,
	  longPressTimeout: null,
	  isProcessingClick: false,
	  autoReadDistance: 100,
	  timeFormat: '24h',
	  contentHeight: 0,
	  preventParagraphSplitting: false,
	  preloadChapter: false,
	  chapterContentCache: null,
	  saveMode: 'exit',
	  saveIntervalValue: 10,
	  alwaysShowTime: false,
	  alwaysShowTimeSensitivity: 50,
	  alwaysShowBattery: true,
	  isNearTopForHd: false,
	  lastTxtSizePage: 400,
	  lastFontSize: 24,
	  readMode: 'scroll',
	  nostalgicPageText: '',
	  nostalgicPageIndex: 0,
	  nostalgicFullContent: '',
	  nostalgicCharsPerPage: 0,
	  nostalgicTotalPages: 0,
	  nostalgicPageTurnMode: 'topBottomClick',
	  textReaderMarqueeEnabled: false,
	  detailProgressMarqueeEnabled: false,
	  boldEnabled: true,
	},
	protected: {
	  name: '',
	  chapterIndex: -1,
	  chapterName: ''
	},
	updateTime() {
	  const date = new Date();
	  let hours = date.getHours();
	  let minutes = date.getMinutes();
	  if (this.timeFormat === '12h') {
		let ampm = hours >= 12 ? '下午' : '上午';
		hours = hours % 12 || 12;
		minutes = minutes < 10 ? '0' + minutes : minutes;
		this.nowTime = `${ampm} ${hours}:${minutes}`;
	  } else {
		hours = hours < 10 ? '0' + hours : hours;
		minutes = minutes < 10 ? '0' + minutes : minutes;
		this.nowTime = `${hours}:${minutes}`;
	  }
	},
	updateBatteryStatus() {
	  battery.getStatus({
		success: (data) => {
		  let level = Math.round(data.level * 100);
		  this.batteryLevel = data.charging ? `充电中 ${level}%` : `电量 ${level}%`;
		}
	  })
	},
	updatePageNumber() {
	  this.currentPage = this.currentChapterIndexInAll + 1;
	  this.totalPages = this.totalChapters;
	},
	onInit() {
	  this.updateTime();
	  this.updateBatteryStatus();
	  this.timer = setInterval(() => {
		this.updateTime();
		this.timeCounter++;
		if (this.timeCounter >= 60) {
		  this.updateBatteryStatus();
		  this.timeCounter = 0;
		}
	  }, 1000);
	  globalThis.isKeepScreenOn = this.isKeepScreenOn;
	  global.runGC();
	},
	async onShow() {
	  await this.loadSettings();
	  const settingsChanged = this.isInitialized && (this.lastTxtSizePage !== this.txtSizePage || this.lastFontSize !== this.fontSize);
	  this.updateBatteryStatus();
	  if (typeof globalThis.isKeepScreenOn !== 'undefined') {
		if (this.isKeepScreenOn !== globalThis.isKeepScreenOn) {
		  this.isKeepScreenOn = globalThis.isKeepScreenOn;
		  brightness.setKeepScreenOn({ keepScreenOn: this.isKeepScreenOn });
		}
	  }
	  storage.get({ key: 'EBOOK_TEACHER_SCREEN_ENABLED', success: (data) => { this.teacherScreenEnabled = data === 'true'; } });
	  const isChapterJump = globalThis.justJumpedFromChapter || globalThis.justJumpedFromBookmark || globalThis.justJumpedFromPageNumber || globalThis.justJumpedFromPercent;
	  if (!this.isInitialized || isChapterJump || settingsChanged) {
		if (globalThis.justJumpedFromChapter) {
		  this.chapterIndex = globalThis.newChapterIndex;
		  this.chapterName = globalThis.newChapterName;
		  delete globalThis.newChapterIndex;
		  delete globalThis.newChapterName;
		}
		await this.loadBook();
		this.isInitialized = true;
		this.lastTxtSizePage = this.txtSizePage;
		this.lastFontSize = this.fontSize;
	  }
	  if (isChapterJump) this.showSetting = false;
	  if (this.name) {
		try { await readingTimeStorage.recordReadingStart(this.name); } catch (e) { }
	  }
	},
	async loadSettings() {
	  const getSetting = (key, defaultValue) => new Promise(resolve => {
		storage.get({ key, success: data => resolve(data !== null && data !== '' ? data : defaultValue), fail: () => resolve(defaultValue) });
	  });
	  const settingsConfig = [
		{ key: 'EBOOK_TXTSZPAGE', prop: 'txtSizePage', type: 'int', default: 400 },
		{ key: 'EBOOK_VERTICAL_MARGIN', prop: 'verticalMargin', type: 'int', default: 20 },
		{ key: 'EBOOK_FONT', prop: 'fontSize', type: 'int', default: 24 },
		{ key: 'EBOOK_OPACITY', prop: 'opacity', type: 'int', default: 100 },
		{ key: 'EBOOK_SWIPE', prop: 'swipe', type: 'string', default: 'column' },
		{ key: 'EBOOK_AUTO', prop: 'auto', type: 'json', default: null },
		{ key: 'EBOOK_GESTURE', prop: 'gestureMode', type: 'string', default: 'single' },
		{ key: 'EBOOK_CHAPTER_SWITCH_HEIGHT', prop: 'chapterSwitchHeight', type: 'int', default: 80 },
		{ key: 'EBOOK_CHAPTER_SWITCH_SENSITIVITY', prop: 'chapterSwitchSensitivity', type: 'int', default: 50 },
		{ key: 'EBOOK_SWIPE_SENSITIVITY', prop: 'swipeSensitivity', type: 'int', default: 80 },
		{ key: 'EBOOK_CHAPTER_SWITCH_STYLE', prop: 'chapterSwitchStyle', type: 'string', default: 'button' },
		{ key: 'EBOOK_AUTO_READ_DISTANCE', prop: 'autoReadDistance', type: 'int', default: 100 },
		{ key: 'EBOOK_PREVENT_PARAGRAPH_SPLITTING', prop: 'preventParagraphSplitting', type: 'bool', default: false },
		{ key: 'EBOOK_PRELOAD_CHAPTER', prop: 'preloadChapter', type: 'bool', default: false },
		{ key: 'EBOOK_TIME_FORMAT', prop: 'timeFormat', type: 'string', default: '24h' },
		{ key: 'EBOOK_PROGRESS_SAVE_MODE', prop: 'saveMode', type: 'string', default: 'exit' },
		{ key: 'EBOOK_PROGRESS_SAVE_INTERVAL', prop: 'saveIntervalValue', type: 'int', default: 10 },
		{ key: 'EBOOK_ALWAYS_SHOW_TIME', prop: 'alwaysShowTime', type: 'bool', default: false },
		{ key: 'EBOOK_ALWAYS_SHOW_TIME_SENSITIVITY', prop: 'alwaysShowTimeSensitivity', type: 'int', default: 200 },
		{ key: 'EBOOK_ALWAYS_SHOW_BATTERY', prop: 'alwaysShowBattery', type: 'bool', default: true },
		{ key: 'EBOOK_READ_MODE', prop: 'readMode', type: 'string', default: 'scroll' },
		{ key: 'EBOOK_TEXT_READER_MARQUEE_ENABLED', prop: 'textReaderMarqueeEnabled', type: 'bool', default: false },
		{ key: 'EBOOK_DETAIL_PROGRESS_MARQUEE_ENABLED', prop: 'detailProgressMarqueeEnabled', type: 'bool', default: false },
		{ key: 'EBOOK_NOSTALGIC_PAGE_TURN_MODE', prop: 'nostalgicPageTurnMode', type: 'string', default: 'topBottomClick' },
		{ key: 'EBOOK_BOLD_ENABLED', prop: 'boldEnabled', type: 'bool', default: true }
	  ];
	  const promises = settingsConfig.map(s => getSetting(s.key, s.default));
	  const results = await Promise.all(promises);
	  results.forEach((data, i) => {
		const config = settingsConfig[i];
		let value = data;
		switch (config.type) {
		  case 'int': this[config.prop] = parseInt(value); break;
		  case 'bool': this[config.prop] = value === 'true' || value === true; break;
		  case 'json': if (value) { const parsed = typeof value === 'string' ? JSON.parse(value) : value; if (parsed && parsed.enable) this.auto = parsed.speed; } break;
		  default: this[config.prop] = value; break;
		}
	  });
	  this.lineHeight = parseInt((-0.01) * (this.fontSize ** 2) + 1.62 * this.fontSize - 3.23);
	  this.updateScrollHeight();
	  if (this.readMode === 'nostalgic') {
		this.calculateNostalgicCharsPerPage();
		if (this.nostalgicFullContent) {
		  this.calculateNostalgicTotalPages();
		  this.updateNostalgicPage();
		}
	  }
	},
	updateContentHeight() { setTimeout(() => { this.$element("contentContainer").getBoundingClientRect({ success: (rect) => { this.contentHeight = rect.height; } }); }, 50); },
	updateScrollHeight() { this.scrollHeight = 514 - this.verticalMargin * 2; this.pageHeigh = Math.floor(this.scrollHeight / this.lineHeight) * this.lineHeight; },
	calculateNostalgicCharsPerPage() {
	  const screenWidth = 212;
	  const screenHeight = this.scrollHeight;
	  if (screenHeight <= 0 || this.lineHeight <= 0 || this.fontSize <= 0) { this.nostalgicCharsPerPage = 100; return; }
	  const linesPerPage = Math.floor(screenHeight / this.lineHeight);
	  if (linesPerPage <= 0) { this.nostalgicCharsPerPage = 100; return; }
	  const charsPerLine = Math.floor(screenWidth / this.fontSize);
	  if (charsPerLine <= 0) { this.nostalgicCharsPerPage = 100; return; }
	  this.nostalgicCharsPerPage = linesPerPage * charsPerLine;
	  if (this.nostalgicCharsPerPage <= 0) this.nostalgicCharsPerPage = 100;
	  if (this.nostalgicCharsPerPage > 10000) this.nostalgicCharsPerPage = 10000;
	},
	calculateNostalgicTotalPages() {
	  if (!this.nostalgicFullContent || this.nostalgicCharsPerPage <= 0) { this.nostalgicTotalPages = 0; return; }
	  const screenWidth = 212; const screenHeight = this.scrollHeight; const linesPerPage = Math.floor(screenHeight / this.lineHeight); const charsPerLine = Math.floor(screenWidth / this.fontSize);
	  if (linesPerPage <= 0 || charsPerLine <= 0) { this.nostalgicTotalPages = 1; return; }
	  let totalPages = 0; let pos = 0; const contentLength = this.nostalgicFullContent.length;
	  while (pos < contentLength) {
		let currentLine = 0; let currentLineChars = 0; let pageStart = pos;
		while (pos < contentLength && currentLine < linesPerPage) {
		  const char = this.nostalgicFullContent[pos];
		  if (char === '\n') { currentLine++; currentLineChars = 0; pos++; }
		  else { currentLineChars++; if (currentLineChars >= charsPerLine) { currentLine++; currentLineChars = 0; } pos++; }
		}
		if (this.preventParagraphSplitting && pos < contentLength) { const lastNewline = this.nostalgicFullContent.lastIndexOf('\n', pos); if (lastNewline > pageStart) pos = lastNewline + 1; }
		if (pos <= pageStart) pos = Math.min(pageStart + this.nostalgicCharsPerPage, contentLength);
		totalPages++;
		if (pos >= contentLength) break;
	  }
	  this.nostalgicTotalPages = totalPages > 0 ? totalPages : 1;
	},
	async loadBook() {
	  try {
		const version = await chapterManager.checkVersion(this.name);
		if (version === 'old') { await chapterManager.handleOldVersion(this.name); return; }
		if (version === 'none') { this.page1 = { text: "本书没有内容", offset: 0, length: 0 }; return; }
		this.totalChapters = await chapterManager.getTotalChapters(this.name);
	  } catch (e) { prompt.showToast({ message: '章节列表加载失败' }); this.totalChapters = 0; return; }
	  if (this.totalChapters === 0) { this.page1 = { text: "本书没有内容", offset: 0, length: 0 }; return; }
	  let progress = await bookStorage.get(this.name);
	  let chapterToLoadIndex; let offsetInChapter = 0; let scrollOffset = 0; let fromChapterJump = false; let shouldScrollToTop = false; let fromBookmark = false; let fromPercent = false;
	  if (globalThis.justJumpedFromChapter) { fromChapterJump = true; chapterToLoadIndex = this.chapterIndex; this.currentChapterName = this.chapterName; offsetInChapter = 0; scrollOffset = 0; shouldScrollToTop = true; globalThis.justJumpedFromChapter = false; }
	  else if (globalThis.justJumpedFromPageNumber) { chapterToLoadIndex = globalThis.justJumpedChapterIndex !== undefined ? globalThis.justJumpedChapterIndex : progress.chapterIndex; offsetInChapter = 0; scrollOffset = 0; shouldScrollToTop = true; globalThis.justJumpedFromPageNumber = false; delete globalThis.justJumpedChapterIndex; }
	  else if (globalThis.justJumpedFromPercent) { fromPercent = true; chapterToLoadIndex = globalThis.justJumpedChapterIndex !== undefined ? globalThis.justJumpedChapterIndex : progress.chapterIndex; offsetInChapter = globalThis.justJumpedOffsetInChapter !== undefined ? globalThis.justJumpedOffsetInChapter : 0; scrollOffset = 0; shouldScrollToTop = false; globalThis.justJumpedFromPercent = false; delete globalThis.justJumpedChapterIndex; delete globalThis.justJumpedOffsetInChapter; }
	  else if (globalThis.justJumpedFromBookmark) { chapterToLoadIndex = globalThis.justJumpedBookmarkChapterIndex !== undefined ? globalThis.justJumpedBookmarkChapterIndex : progress.chapterIndex; offsetInChapter = progress.offsetInChapter || 0; scrollOffset = progress.scrollOffset || 0; fromBookmark = true; globalThis.justJumpedFromBookmark = false; delete globalThis.justJumpedBookmarkChapterIndex; }
	  else if (progress.chapterIndex !== null) { chapterToLoadIndex = progress.chapterIndex; offsetInChapter = progress.offsetInChapter || 0; scrollOffset = progress.scrollOffset || 0; }
	  else { chapterToLoadIndex = 0; }
	  if (chapterToLoadIndex === null || chapterToLoadIndex === undefined) { const available = await chapterManager.getAllAvailableChapters(this.name); if (available.length > 0) chapterToLoadIndex = available[0].index; else { this.page1 = { text: "本书没有内容", offset: 0, length: 0 }; return; } }
	  else { const ch = await chapterManager.getChapterByIndex(this.name, chapterToLoadIndex); if (!ch) { const available = await chapterManager.getAllAvailableChapters(this.name); if (available.length > 0) chapterToLoadIndex = available[0].index; } }
	  const oldTxtSizePage = progress.txtSizePage || this.txtSizePage; const oldFontSize = progress.fontSize || this.fontSize;
	  if (oldTxtSizePage !== this.txtSizePage || oldFontSize !== this.fontSize) { const fontSizeRatio = oldFontSize > 0 ? this.fontSize / oldFontSize : 1; const txtSizePageRatio = oldTxtSizePage > 0 ? this.txtSizePage / oldTxtSizePage : 1; if (txtSizePageRatio !== 1 && offsetInChapter > 0) offsetInChapter = Math.floor(offsetInChapter * txtSizePageRatio); if (fontSizeRatio !== 1 && scrollOffset > 0) scrollOffset = Math.floor(scrollOffset * fontSizeRatio); }
	  progress = null;
	  let chapterArrayIndex = chapterToLoadIndex;
	  if (chapterArrayIndex < 0 || chapterArrayIndex >= this.totalChapters) { chapterToLoadIndex = 0; chapterArrayIndex = 0; }
	  this.currentFileOffset = offsetInChapter; this.savedScrollOffset = scrollOffset; this.scrollTopValue = scrollOffset; this.currentScrollTop = scrollOffset;
	  this._shouldScrollToTop = shouldScrollToTop; this._fromBookmark = fromBookmark; this._bookmarkOffsetInChapter = fromBookmark ? offsetInChapter : null; this._fromPercent = fromPercent; this._percentOffsetInChapter = fromPercent ? offsetInChapter : null;
	  this.loadChapter(chapterArrayIndex, () => {
		if (this.readMode === 'nostalgic') { this.wait = false; this.loadNostalgicChapter(offsetInChapter); }
		else { this.loadInitialSegments(); if (fromChapterJump || shouldScrollToTop) { this.isAtChapterStart = shouldScrollToTop; } else if (this.currentFileOffset === 0 && this.savedScrollOffset < 10) { this.isAtChapterStart = true; } else { this.isAtChapterStart = false; } this.isNearTopForHd = this.currentFileOffset === 0 && this.savedScrollOffset < this.alwaysShowTimeSensitivity; }
	  });
	},
	async loadChapter(chapterIdxInAll, callback) {
	  if (chapterIdxInAll < 0 || chapterIdxInAll >= this.totalChapters) { if (callback) callback(); return; }
	  const chapter = await chapterManager.getChapterByIndex(this.name, chapterIdxInAll);
	  if (!chapter) { prompt.showToast({ message: '无法加载章节信息' }); if (callback) callback(); return; }
	  if (this.page1) this.page1.text = null; if (this.page2) this.page2.text = null;
	  this.page1 = { text: "", offset: 0, length: 0 }; this.page2 = null;
	  this.isAtChapterStart = false; this.isAtChapterEnd = false;
	  this.currentChapterIndexInAll = chapterIdxInAll; this.currentChapterName = chapter.name;
	  this.cPath = `internal://files/books/${this.name}/content/${chapter.index}.txt`;
	  this.chapterContentCache = null;
	  file.get({
		uri: this.cPath,
		success: (data) => {
		  this.allSize = data.length; this.updatePageNumber();
		  if (this.readMode === 'nostalgic' || (this.preloadChapter && this.allSize > 0)) {
			file.readArrayBuffer({
			  uri: this.cPath,
			  success: (arrData) => {
				try { if (!arrData.buffer || arrData.buffer.byteLength === 0) this.chapterContentCache = ""; else { const buffer = new Uint8Array(arrData.buffer); const chars = []; for (let i = 0; i < buffer.length; i += 2) chars.push(String.fromCharCode(buffer[i + 1] * 256 + buffer[i])); this.chapterContentCache = chars.join(''); if (this.readMode === 'nostalgic') this.nostalgicFullContent = this.chapterContentCache; } } catch (e) { this.chapterContentCache = null; if (this.readMode === 'nostalgic') this.nostalgicFullContent = ""; }
				if (callback) callback();
			  },
			  fail: (data, code) => { this.chapterContentCache = null; if (this.readMode === 'nostalgic') this.nostalgicFullContent = ""; if (callback) callback(); }
			});
		  } else { if (callback) callback(); }
		},
		fail: (data, code) => { this.allSize = 0; if (callback) callback(); }
	  });
	},
	loadInitialSegments() { var that = this; this.wait = true; this.readFileText(this.currentFileOffset, function (str, bytesRead) { that.page1 = { text: str, offset: that.currentFileOffset, length: bytesRead }; that.loadNextSegmentNoScroll(); that.updateContentHeight(); }); },
	loadNextSegmentNoScroll() { var that = this; let lastSeg = that.page2 || that.page1; let newOffset = lastSeg.offset + lastSeg.length; if (newOffset >= this.allSize) { that.isAtChapterEnd = true; that.page2 = null; that.restoreScrollPosition(); return; } that.readFileText(newOffset, function (str, bytesRead) { if (str) that.page2 = { text: str, offset: newOffset, length: bytesRead }; else that.page2 = null; that.restoreScrollPosition(); that.updateContentHeight(); }); },
	restoreScrollPosition() {
	  setTimeout(() => {
		const shouldScrollToTop = this._shouldScrollToTop || (this.currentFileOffset === 0 && this.savedScrollOffset === 0);
		if (shouldScrollToTop) { this.scrollTopValue = 0; this.currentScrollTop = 0; this.currentFileOffset = 0; this.savedScrollOffset = 0; this.finalizeScrollRestore(); }
		else {
		  const targetOffset = (this._fromBookmark && this._bookmarkOffsetInChapter !== null && this._bookmarkOffsetInChapter > 0) ? this._bookmarkOffsetInChapter : (this._fromPercent && this._percentOffsetInChapter !== null && this._percentOffsetInChapter > 0) ? this._percentOffsetInChapter : null;
		  if (targetOffset !== null && targetOffset > 0) {
			this.$element("page1").getBoundingClientRect({
			  success: (page1Rect) => {
				const page1StartOffset = this.page1.offset; const page1EndOffset = page1StartOffset + this.page1.length;
				if (targetOffset >= page1StartOffset && targetOffset < page1EndOffset) { const offsetInPage1 = targetOffset - page1StartOffset; const charsInPage1 = offsetInPage1 / 2; const avgCharWidth = this.fontSize * 0.6; const charsPerLine = Math.floor(212 / avgCharWidth); const linesInPage1 = Math.ceil(charsInPage1 / charsPerLine); const heightInPage1 = linesInPage1 * this.lineHeight; const totalScroll = heightInPage1 + this.savedScrollOffset; this.scrollTopValue = Math.max(0, Math.floor(totalScroll)); this.currentScrollTop = Math.max(0, Math.floor(totalScroll)); }
				else { this.scrollTopValue = Math.max(0, Math.floor(this.savedScrollOffset)); this.currentScrollTop = Math.max(0, Math.floor(this.savedScrollOffset)); }
				this.finalizeScrollRestore();
			  },
			  fail: () => { this.scrollTopValue = Math.max(0, Math.floor(this.savedScrollOffset)); this.currentScrollTop = Math.max(0, Math.floor(this.savedScrollOffset)); this.finalizeScrollRestore(); }
			});
		  } else { this.scrollTopValue = Math.max(0, Math.floor(this.savedScrollOffset)); this.currentScrollTop = Math.max(0, Math.floor(this.savedScrollOffset)); this.finalizeScrollRestore(); }
		}
	  }, 100);
	},
	finalizeScrollRestore() { this.$element("contentContainer").getBoundingClientRect({ success: (rect) => { this.contentHeight = rect.height; this.wait = false; this._shouldScrollToTop = false; this._fromBookmark = false; this._bookmarkOffsetInChapter = null; this._fromPercent = false; this._percentOffsetInChapter = null; this.saveData(true); }, fail: () => { this.wait = false; this._shouldScrollToTop = false; this._fromBookmark = false; this._bookmarkOffsetInChapter = null; this._fromPercent = false; this._percentOffsetInChapter = null; } }); },
	readFileText(readOffset, cb) {
	  if (readOffset >= this.allSize) { cb('', 0); return; }
	  if (this.chapterContentCache) { const start = readOffset / 2; let end = start + this.txtSizePage; if (end > this.chapterContentCache.length) end = this.chapterContentCache.length; let str = this.chapterContentCache.substring(start, end); if (this.preventParagraphSplitting && end < this.chapterContentCache.length) { const lastNewline = str.lastIndexOf('\n'); if (lastNewline > -1) str = str.substring(0, lastNewline + 1); } const bytesRead = str.length * 2; cb(str, bytesRead); return; }
	  var length = this.txtSizePage * 2; if (readOffset < 0) { length += readOffset; readOffset = 0; } if ((readOffset + length) >= this.allSize) length = this.allSize - readOffset;
	  const self = this;
	  function attemptRead(len, attemptsLeft) { file.readArrayBuffer({ uri: self.cPath, position: readOffset, length: len, success: (data) => { if (!data.buffer || data.buffer.byteLength === 0) { cb('', 0); return; } try { const buffer = new Uint8Array(data.buffer); const chars = []; for (let i = 0; i < buffer.length; i += 2) chars.push(String.fromCharCode(buffer[i + 1] * 256 + buffer[i])); let str = chars.join(''); let bytesRead = len; if (self.preventParagraphSplitting && (readOffset + len) < self.allSize) { const lastNewline = str.lastIndexOf('\n'); if (lastNewline > -1) { str = str.substring(0, lastNewline + 1); bytesRead = str.length * 2; } } cb(str, bytesRead); } catch (e) { cb('', 0); } }, fail: function (data, code) { if (attemptsLeft > 0) { const nextLen = Math.max(256, Math.floor(len / 2)); attemptRead(nextLen, attemptsLeft - 1); return; } cb('', 0); } }); }
	  attemptRead(length, 3);
	},
	onScroll(e) { if (this.wait) return; if (this.isAtChapterEnd && e.scrollY < this.currentScrollTop) this.isAtChapterEnd = false; this.currentScrollTop = e.scrollY; this.isAtChapterStart = this.currentFileOffset === 0 && this.currentScrollTop < 10; this.isNearTopForHd = this.currentFileOffset === 0 && this.currentScrollTop < this.alwaysShowTimeSensitivity; if (this.contentHeight > this.scrollHeight) { const threshold = this.auto ? 40 : this.chapterSwitchSensitivity; const isNearBottom = this.currentScrollTop >= (this.contentHeight - this.scrollHeight - threshold); if (isNearBottom) { let lastSeg = this.page2 || this.page1; let newOffset = lastSeg.offset + lastSeg.length; if (newOffset >= this.allSize) this.isAtChapterEnd = true; } } },
	onScrollTop() { if (this.wait) return; if (this.currentFileOffset > 0) { if (!this.loadingPrev) { this.loadingPrev = true; this.loadPrevSegment(); } } },
	onScrollBottom() { if (this.wait) return; if (!this.loadingNext) { this.loadingNext = true; this.loadNextSegment(); } },
	loadNextSegment() { this.wait = true; var that = this; let lastSeg = that.page2 || that.page1; let newOffset = lastSeg.offset + lastSeg.length; if (newOffset >= this.allSize) { that.loadingNext = false; that.isAtChapterEnd = true; that.wait = false; return; } this.readFileText(newOffset, function (str, bytesRead) { that.loadingNext = false; if (str) { const nextPageData = { text: str, offset: newOffset, length: bytesRead }; that.shiftPagesForward(nextPageData); } else that.wait = false; }); },
	shiftPagesForward(nextPageData) { var that = this; const scrollPosBeforeLoad = this.currentScrollTop; that.$element("page1").getBoundingClientRect({ success: function (rect) { let removedHeight = rect.height; that.page1 = that.page2; that.page2 = nextPageData; const newScrollPos = scrollPosBeforeLoad - removedHeight + that.lineHeight; that.scrollTopValue = Math.max(0, newScrollPos); that.currentScrollTop = Math.max(0, newScrollPos); that.currentFileOffset = that.page1.offset; that.saveData(true); that.wait = false; that.updateContentHeight(); }, fail: function () { that.wait = false; } }); },
	loadPrevSegment() { this.wait = true; var that = this; if (that.page1.offset <= 0) { this.wait = false; this.loadingPrev = false; return; } let newOffset = that.page1.offset - this.txtSizePage * 2; if (newOffset < 0) newOffset = 0; this.readFileText(newOffset, function (str, bytesRead) { that.loadingPrev = false; if (str) { const prevPageData = { text: str, offset: newOffset, length: bytesRead }; let oldPage2 = that.page2; if (oldPage2) oldPage2.text = null; that.page2 = that.page1; that.page1 = prevPageData; oldPage2 = null; that.$element("page1").getBoundingClientRect({ success: function (rect) { const newScrollPos = that.currentScrollTop + rect.height; that.scrollTopValue = newScrollPos; that.currentScrollTop = newScrollPos; that.currentFileOffset = that.page1.offset; that.saveData(true); that.wait = false; that.updateContentHeight(); }, fail: function () { that.wait = false; } }); } else that.wait = false; }); },
	onTouchStart(e) { this.isTouching = true; this.touchStartY = e.touches[0].clientY; if (this.chapterSwitchStyle === 'swipe') { this.touchStartX = e.touches[0].clientX; } },
	onTouchMove(e) { if (!this.isTouching) return; if (this.chapterSwitchStyle === 'boundary') { const currentY = e.touches[0].clientY; const deltaY = currentY - this.touchStartY; if (this.isAtChapterStart && deltaY > 0) this.overscrollDistance = deltaY; else if (this.isAtChapterEnd && deltaY < 0) this.overscrollDistance = -deltaY; else this.overscrollDistance = 0; } else if (this.chapterSwitchStyle === 'swipe') this.touchEndX = e.touches[0].clientX; },
	onTouchEnd(e) { if (!this.isTouching) return; this.isTouching = false; if (this.chapterSwitchStyle === 'boundary') { if (this.overscrollDistance > this.chapterSwitchSensitivity) { if (this.isAtChapterStart) this.goToPrevChapter(); else if (this.isAtChapterEnd) this.goToNextChapter(); } this.overscrollDistance = 0; this.touchStartY = 0; } else if (this.chapterSwitchStyle === 'swipe') { if (this.touchStartX === 0) return; const deltaX = this.touchEndX - this.touchStartX; if (Math.abs(deltaX) > this.swipeSensitivity) { if (deltaX > 0) this.goToPrevChapter(); else this.goToNextChapter(); } this.touchStartX = 0; this.touchEndX = 0; } },
	goToPrevChapter() { if (this.wait) return; this.wait = true; const prevChapterIndex = this.currentChapterIndexInAll - 1; if (prevChapterIndex < 0) { prompt.showToast({ message: '已是第一章' }); this.wait = false; return; } global.runGC(); this.isAtChapterEnd = false; this.currentFileOffset = 0; this.savedScrollOffset = 0; this.scrollTopValue = 0; this.currentScrollTop = 0; this.loadChapter(prevChapterIndex, () => { if (this.readMode === 'nostalgic') this.loadNostalgicChapter(-1); else { this.page1 = { text: "加载中...", offset: 0, length: 0 }; this.page2 = null; this.loadInitialSegments(); this.isAtChapterStart = true; this.isNearTopForHd = true; } this.chapterProgress = 0; this.saveData(true); }); },
	goToNextChapter() { if (this.wait) return; this.wait = true; const nextChapterIndex = this.currentChapterIndexInAll + 1; if (nextChapterIndex >= this.totalChapters) { prompt.showToast({ message: '已是最后一章' }); if (this.autoInterval) { clearInterval(this.autoInterval); this.autoInterval = null; } this.wait = false; return; } global.runGC(); this.isAtChapterEnd = false; this.currentFileOffset = 0; this.savedScrollOffset = 0; this.scrollTopValue = 0; this.currentScrollTop = 0; this.loadChapter(nextChapterIndex, () => { if (this.readMode === 'nostalgic') this.loadNostalgicChapter(0); else { this.page1 = { text: "加载中...", offset: 0, length: 0 }; this.page2 = null; this.loadInitialSegments(); this.isAtChapterStart = false; this.isNearTopForHd = true; } this.chapterProgress = 0; this.saveData(true); }); },
	saveData(forceImmediate = false) { if (this.saveDataTimeout) { clearTimeout(this.saveDataTimeout); this.saveDataTimeout = null; } if (forceImmediate) this._performSave(); else if (this.saveMode === 'periodic' && this.saveIntervalValue > 0) { this.saveDataTimeout = setTimeout(() => { this._performSave(); this.saveDataTimeout = null; }, this.saveIntervalValue * 1000); } },
	async _performSave() { if (!this.name || this.totalChapters === 0) return; try { let progress = await bookStorage.get(this.name); progress.chapterIndex = this.currentChapterIndexInAll; if (this.readMode === 'nostalgic') { if (this.nostalgicPageIndex >= 0 && this.nostalgicTotalPages > 0) { const charOffset = this.nostalgicPageIndex * this.nostalgicCharsPerPage; progress.offsetInChapter = Math.max(0, charOffset * 2); progress.scrollOffset = 0; } else { progress.offsetInChapter = 0; progress.scrollOffset = 0; } } else { progress.offsetInChapter = Math.max(0, Math.floor(this.currentFileOffset || 0)); progress.scrollOffset = Math.max(0, Math.floor(this.currentScrollTop || 0)); } progress.txtSizePage = this.txtSizePage; progress.fontSize = this.fontSize; progress.lastReadTimestamp = Date.now(); const chapterProgressValue = parseFloat(this.chapterProgress); progress.chapterProgressPercent = isNaN(chapterProgressValue) ? 0 : Math.min(100, Math.max(0, chapterProgressValue)); await bookStorage.set(this.name, progress); progress = null; } catch (e) { } },
	async onHide() { if (this.saveDataTimeout) { clearTimeout(this.saveDataTimeout); this.saveDataTimeout = null; } if (this.autoInterval) { clearInterval(this.autoInterval); this.autoInterval = null; } try { await this._performSave(); } catch (e) { } if (this.name) { try { await readingTimeStorage.recordReadingEnd(this.name); } catch (e) { } } brightness.setKeepScreenOn({ keepScreenOn: false }); },
	async onDestroy() { if (this.saveDataTimeout) { clearTimeout(this.saveDataTimeout); this.saveDataTimeout = null; } if (this.timer) { clearInterval(this.timer); this.timer = null; } if (this.autoInterval) { clearInterval(this.autoInterval); this.autoInterval = null; } try { await this._performSave(); } catch (e) { } if (this.name) { try { await readingTimeStorage.recordReadingEnd(this.name); } catch (e) { } } brightness.setKeepScreenOn({ keepScreenOn: false }); global.runGC(); },
	onBackPress() { if (this.readMode === 'nostalgic' && this.nostalgicPageTurnMode === 'swipe' && this.nostalgicIsTouching) { if (this.nostalgicPageIndex > 0) this.nostalgicPrevPage(); else if (this.currentChapterIndexInAll > 0) this.goToPrevChapter(); return true; } },
	async back() { if (this.saveDataTimeout) { clearTimeout(this.saveDataTimeout); this.saveDataTimeout = null; } if (this.autoInterval) { clearInterval(this.autoInterval); this.autoInterval = null; } try { await this._performSave(); } catch (e) { } if (this.name) { try { await readingTimeStorage.recordReadingEnd(this.name); } catch (e) { } } router.back(); },
	async gotoSetting() { if (this.isProcessingClick) return; this.isProcessingClick = true; this.saveData(true); if (this.name) { try { await readingTimeStorage.recordReadingEnd(this.name); } catch (e) { } } router.push({ uri: '/pages/detailsetting', params: { name: this.name } }); setTimeout(() => { this.isProcessingClick = false; }, 500); },
	async exitAppForTeacherScreen() { if (this.saveDataTimeout) { clearTimeout(this.saveDataTimeout); this.saveDataTimeout = null; } if (this.autoInterval) { clearInterval(this.autoInterval); this.autoInterval = null; } try { await this._performSave(); } catch (e) { } app.terminate(); },
	loadNostalgicChapter(offsetInChapter) { if (!this.nostalgicFullContent) { this.nostalgicPageText = "加载中..."; this.nostalgicPageIndex = 0; this.nostalgicTotalPages = 0; this.wait = false; return; } this.calculateNostalgicCharsPerPage(); this.calculateNostalgicTotalPages(); if (offsetInChapter === -1) this.nostalgicPageIndex = Math.max(0, this.nostalgicTotalPages - 1); else if (offsetInChapter > 0 && this.nostalgicFullContent.length > 0 && this.nostalgicCharsPerPage > 0) { const charOffset = offsetInChapter / 2; const targetPageIndex = Math.floor(charOffset / this.nostalgicCharsPerPage); this.nostalgicPageIndex = Math.min(targetPageIndex, Math.max(0, this.nostalgicTotalPages - 1)); } else this.nostalgicPageIndex = 0; this.updateNostalgicPage(); this.isAtChapterStart = this.nostalgicPageIndex === 0; this.isAtChapterEnd = this.nostalgicPageIndex >= this.nostalgicTotalPages - 1; this.isNearTopForHd = this.nostalgicPageIndex === 0; this.wait = false; },
	getNostalgicPageText(pageIndex) {
	  if (!this.nostalgicFullContent || this.nostalgicCharsPerPage <= 0 || pageIndex < 0 || pageIndex >= this.nostalgicTotalPages) return "";
	  const screenWidth = 212; const screenHeight = this.scrollHeight; const linesPerPage = Math.floor(screenHeight / this.lineHeight); const charsPerLine = Math.floor(screenWidth / this.fontSize);
	  if (linesPerPage <= 0 || charsPerLine <= 0) return this.nostalgicFullContent;
	  const contentLength = this.nostalgicFullContent.length; let pos = 0; let currentPage = 0;
	  if (pageIndex > 0) { pos = pageIndex < 50 ? 0 : Math.max(0, Math.min(pageIndex * this.nostalgicCharsPerPage, contentLength) - this.nostalgicCharsPerPage * 2); currentPage = pageIndex < 50 ? 0 : Math.floor(pos / this.nostalgicCharsPerPage); }
	  while (pos < contentLength && currentPage < pageIndex) { let pageStart = pos; let currentLine = 0; let currentLineChars = 0; while (pos < contentLength && currentLine < linesPerPage) { const char = this.nostalgicFullContent[pos]; if (char === '\n') { currentLine++; currentLineChars = 0; pos++; } else { currentLineChars++; if (currentLineChars >= charsPerLine) { currentLine++; currentLineChars = 0; } pos++; } } if (this.preventParagraphSplitting && pos < contentLength) { const lastNewline = this.nostalgicFullContent.lastIndexOf('\n', pos); if (lastNewline > pageStart) pos = lastNewline + 1; } if (pos <= pageStart) pos = Math.min(pageStart + this.nostalgicCharsPerPage, contentLength); currentPage++; if (pos >= contentLength) break; }
	  const pageStart = pos; let currentLine = 0; let currentLineChars = 0; let pageEnd = pos; while (pageEnd < contentLength && currentLine < linesPerPage) { const char = this.nostalgicFullContent[pageEnd]; if (char === '\n') { currentLine++; currentLineChars = 0; pageEnd++; } else { currentLineChars++; if (currentLineChars >= charsPerLine) { currentLine++; currentLineChars = 0; } pageEnd++; } } if (this.preventParagraphSplitting && pageEnd < contentLength) { const lastNewline = this.nostalgicFullContent.lastIndexOf('\n', pageEnd); if (lastNewline > pageStart) pageEnd = lastNewline + 1; } if (pageEnd <= pageStart) pageEnd = Math.min(pageStart + this.nostalgicCharsPerPage, contentLength); return this.nostalgicFullContent.substring(pageStart, pageEnd);
	},
	updateNostalgicPage() { if (!this.nostalgicFullContent || this.nostalgicTotalPages === 0) { this.nostalgicPageText = ""; return; } if (this.nostalgicPageIndex < 0) this.nostalgicPageIndex = 0; if (this.nostalgicPageIndex >= this.nostalgicTotalPages) this.nostalgicPageIndex = this.nostalgicTotalPages - 1; this.nostalgicPageText = this.getNostalgicPageText(this.nostalgicPageIndex); this.isAtChapterStart = this.nostalgicPageIndex === 0; this.isAtChapterEnd = this.nostalgicPageIndex >= this.nostalgicTotalPages - 1; this.saveData(true); },
	onNostalgicTouchStart(e) { if (this.nostalgicPageTurnMode === 'swipe') { this.nostalgicIsTouching = true; this.nostalgicTouchStartX = e.touches[0].clientX; this.nostalgicTouchStartY = e.touches[0].clientY; } },
	onNostalgicTouchMove(e) { if (this.nostalgicPageTurnMode === 'swipe' && this.nostalgicIsTouching) { this.nostalgicTouchEndX = e.touches[0].clientX; this.nostalgicTouchEndY = e.touches[0].clientY; } },
	onNostalgicTouchEnd(e) { if (this.nostalgicPageTurnMode === 'swipe' && this.nostalgicIsTouching) { this.nostalgicIsTouching = false; const deltaX = this.nostalgicTouchEndX - this.nostalgicTouchStartX; const deltaY = this.nostalgicTouchEndY - this.nostalgicTouchStartY; if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) { if (this.nostalgicPageIndex < this.nostalgicTotalPages - 1) this.nostalgicNextPage(); else if (this.currentChapterIndexInAll < this.totalChapters - 1) this.goToNextChapter(); } } },
	onNostalgicClick(event) { if (this.wait) return; if (this.nostalgicPageTurnMode === 'swipe') { if (this.gestureMode === 'double') { this.gestureClickCount++; if (this.gestureClickTimeout) clearTimeout(this.gestureClickTimeout); if (this.gestureClickCount === 2) { this.gestureClickCount = 0; this.showSetting = !this.showSetting; } else this.gestureClickTimeout = setTimeout(() => { this.gestureClickCount = 0; if (!this.showSetting) this.showSetting = true; }, 300); } else this.showSetting = !this.showSetting; return; } if (this.teacherScreenEnabled) { this.clickCount++; if (this.clickTimeout) clearTimeout(this.clickTimeout); if (this.clickCount >= 3) { this.clickCount = 0; this.exitAppForTeacherScreen(); return; } this.clickTimeout = setTimeout(() => { this.clickCount = 0; }, 500); } if (this.nostalgicPageTurnMode === 'sideClick') { if (this.gestureMode === 'double') { this.gestureClickCount++; if (this.gestureClickTimeout) clearTimeout(this.gestureClickTimeout); if (this.gestureClickCount === 2) { this.gestureClickCount = 0; this.showSetting = !this.showSetting; } else this.gestureClickTimeout = setTimeout(() => { this.gestureClickCount = 0; if (!this.showSetting) { const clickX = event.offsetX || (event.detail && event.detail.x) || 0; if (clickX < 70) { if (this.isAtChapterStart && this.currentChapterIndexInAll > 0) this.goToPrevChapter(); else this.nostalgicPrevPage(); } else if (clickX > 142) { if (this.isAtChapterEnd && this.currentChapterIndexInAll < this.totalChapters - 1) this.goToNextChapter(); else this.nostalgicNextPage(); } } }, 300); } else { if (this.showSetting) this.showSetting = false; else { const clickX = event.offsetX || (event.detail && event.detail.x) || 0; if (clickX < 70) { if (this.isAtChapterStart && this.currentChapterIndexInAll > 0) this.goToPrevChapter(); else this.nostalgicPrevPage(); } else if (clickX > 142) { if (this.isAtChapterEnd && this.currentChapterIndexInAll < this.totalChapters - 1) this.goToNextChapter(); else this.nostalgicNextPage(); } else this.showSetting = true; } } } else if (this.nostalgicPageTurnMode === 'topBottomClick') { if (this.gestureMode === 'double') { this.gestureClickCount++; if (this.gestureClickTimeout) clearTimeout(this.gestureClickTimeout); if (this.gestureClickCount === 2) { this.gestureClickCount = 0; this.showSetting = !this.showSetting; } else this.gestureClickTimeout = setTimeout(() => { this.gestureClickCount = 0; if (!this.showSetting) { const clickY = event.offsetY || (event.detail && event.detail.y) || 0; if (clickY < this.scrollHeight / 3) { if (this.isAtChapterStart && this.currentChapterIndexInAll > 0) this.goToPrevChapter(); else this.nostalgicPrevPage(); } else if (clickY > this.scrollHeight * 2 / 3) { if (this.isAtChapterEnd && this.currentChapterIndexInAll < this.totalChapters - 1) this.goToNextChapter(); else this.nostalgicNextPage(); } } }, 300); } else { if (this.showSetting) this.showSetting = false; else { const clickY = event.offsetY || (event.detail && event.detail.y) || 0; if (clickY < this.scrollHeight / 3) { if (this.isAtChapterStart && this.currentChapterIndexInAll > 0) this.goToPrevChapter(); else this.nostalgicPrevPage(); } else if (clickY > this.scrollHeight * 2 / 3) { if (this.isAtChapterEnd && this.currentChapterIndexInAll < this.totalChapters - 1) this.goToNextChapter(); else this.nostalgicNextPage(); } else this.showSetting = true; } } } },
	nostalgicNextPage() { if (this.nostalgicPageIndex < this.nostalgicTotalPages - 1) { this.nostalgicPageIndex++; this.updateNostalgicPage(); } else this.isAtChapterEnd = true; },
	nostalgicPrevPage() { if (this.nostalgicPageIndex > 0) { this.nostalgicPageIndex--; this.updateNostalgicPage(); } },
	onTxtClick(event) {
	  if (this.wait) return;
	  if (this.teacherScreenEnabled) { this.clickCount++; if (this.clickTimeout) clearTimeout(this.clickTimeout); if (this.clickCount >= 3) { this.clickCount = 0; this.exitAppForTeacherScreen(); return; } this.clickTimeout = setTimeout(() => { this.clickCount = 0; }, 500); }
	  if (this.gestureMode === 'double') { this.gestureClickCount++; if (this.gestureClickTimeout) clearTimeout(this.gestureClickTimeout); if (this.gestureClickCount === 2) { this.gestureClickCount = 0; this.showSetting = !this.showSetting; } else { this.gestureClickTimeout = setTimeout(() => { this.gestureClickCount = 0; if (this.swipe !== 'column' && this.showSetting) this.showSetting = false; else if (this.swipe !== 'column' && !this.showSetting) { if (event.offsetY <= 158) this.lastPage(); else if (event.offsetY > 322) this.nextPage(); } }, 300); } }
	  else { if (this.swipe === 'column') this.showSetting = !this.showSetting; else { if (this.showSetting) this.showSetting = false; else { if (event.offsetY <= 158) this.lastPage(); else if (event.offsetY <= 322) this.showSetting = true; else this.nextPage(); } } }
	},
	onTxtLongPress(event) {
	  if (this.auto) {
		if (this.autoInterval) { clearInterval(this.autoInterval); this.autoInterval = null; prompt.showToast({ message: '已关闭自动翻页' }); return; }
		this.autoInterval = setInterval(() => { if (this.wait) return; if (this.readMode === 'nostalgic') { if (this.isAtChapterEnd) this.goToNextChapter(); else this.nostalgicNextPage(); } else { if (this.isAtChapterEnd) this.goToNextChapter(); else this.nextPage(); } }, this.auto * 1000);
		prompt.showToast({ message: '已开启自动翻页' });
	  }
	},
	lastPage() { this.$element("scrollId").scrollBy({ top: - (this.pageHeigh * (this.autoReadDistance / 100)), behavior: 'smooth' }); },
	nextPage() { this.$element("scrollId").scrollBy({ top: (this.pageHeigh * (this.autoReadDistance / 100)), behavior: 'smooth' }); }
  }
  </script>
  <style>
.page {
	width: 192px;
	height: 490px;
	background-color: #000000;
}
</style>
